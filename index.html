<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Daily David (Spiritual Growth Tool)</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Neon Database Client - Bundled -->
    <script src="dev/dist/neon-client.js"></script>
    <!-- Neon User Management System -->

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#047857', // Slightly darker green for dev
                        secondary: '#10b981',
                        accent: '#34d399',
                    }
                }
            }
        }
    </script>
    <style>
        /* Modern Typography Scale */
        :root {
            --font-xs: 0.75rem;    /* 12px */
            --font-sm: 0.875rem;   /* 14px */
            --font-base: 1rem;     /* 16px */
            --font-lg: 1.125rem;   /* 18px */
            --font-xl: 1.25rem;    /* 20px */
            --font-2xl: 1.5rem;    /* 24px */
            --font-3xl: 1.875rem;  /* 30px */
            --font-4xl: 2.25rem;   /* 36px */
            
            --spacing-1: 0.25rem;  /* 4px */
            --spacing-2: 0.5rem;   /* 8px */
            --spacing-3: 0.75rem;  /* 12px */
            --spacing-4: 1rem;     /* 16px */
            --spacing-5: 1.25rem;  /* 20px */
            --spacing-6: 1.5rem;   /* 24px */
            --spacing-8: 2rem;     /* 32px */
            --spacing-10: 2.5rem;  /* 40px */
            --spacing-12: 3rem;    /* 48px */
        }

        /* Enhanced Typography */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            letter-spacing: -0.01em;
            font-size: var(--font-base);
        }

        h1, h2, h3, h4, h5, h6 {
            font-weight: 600;
            line-height: 1.3;
            letter-spacing: -0.02em;
        }

        /* Apply font variables to specific elements */
        .text-xs { font-size: var(--font-xs); }
        .text-sm { font-size: var(--font-sm); }
        .text-base { font-size: var(--font-base); }
        .text-lg { font-size: var(--font-lg); }
        .text-xl { font-size: var(--font-xl); }
        .text-2xl { font-size: var(--font-2xl); }
        .text-3xl { font-size: var(--font-3xl); }
        .text-4xl { font-size: var(--font-4xl); }

        /* Modern Card System */
        .section-divider {
            background: linear-gradient(90deg, transparent, #e5e7eb, transparent);
            height: 2px;
            margin: var(--spacing-8) 0;
            border-radius: 1px;
        }

        .section-card {
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            border: 1px solid #e2e8f0;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            border-radius: 16px;
            transition: all 0.2s ease;
        }

        .section-header {
            background: linear-gradient(135deg, #94a3b8 0%, #059669 100%);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 700;
            font-size: var(--font-2xl);
        }

        .status-indicator {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Enhanced Modern Cards */
        .modern-card {
            background: linear-gradient(135deg, #ffffff 0%, #f1f5f9 100%);
            border: 2px solid #cbd5e1;
            box-shadow: 0 8px 16px -1px rgba(0, 0, 0, 0.1), 0 4px 8px -1px rgba(0, 0, 0, 0.06);
            border-radius: 20px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
            position: relative;
        }

        .modern-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Prevent browser autocomplete styling and credential prompts */
        input:-webkit-autofill,
        input:-webkit-autofill:hover,
        input:-webkit-autofill:focus,
        input:-webkit-autofill:active {
            -webkit-box-shadow: 0 0 0 30px white inset !important;
            -webkit-text-fill-color: inherit !important;
            transition: background-color 5000s ease-in-out 0s;
        }

        input[autocomplete="off"] {
            background-color: white !important;
        }

        /* Additional credential prompt prevention */
        input[type="email"][autocomplete="off"],
        input[type="password"][autocomplete="off"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        .modern-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #059669 0%, #10b981 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .modern-card:hover::before {
            opacity: 1;
        }

        .modern-card:hover {
            transform: translateY(-6px);
            box-shadow: 0 25px 35px -5px rgba(0, 0, 0, 0.15), 0 15px 15px -5px rgba(0, 0, 0, 0.08);
            border-color: #059669;
        }

        .modern-card:focus-within {
            box-shadow: 0 0 0 4px rgba(5, 150, 105, 0.15);
            border-color: #059669;
        }

        .soap-card {
            background: linear-gradient(135deg, #fefefe 0%, #f9fafb 100%);
            border: 2px solid #e5e7eb;
            box-shadow: 0 8px 25px -3px rgba(0, 0, 0, 0.1);
            border-radius: 20px;
            transition: all 0.2s ease;
        }

        .soap-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 30px -3px rgba(0, 0, 0, 0.15);
        }

        /* Enhanced Slider Styling */
        .slider {
            -webkit-appearance: none;
            appearance: none;
            background: #e5e7eb;
            outline: none;
            border-radius: 12px;
            transition: all 0.2s ease;
            height: 6px;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #059669;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(5, 150, 105, 0.3);
            transition: all 0.2s ease;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 12px rgba(5, 150, 105, 0.4);
        }

        .slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #059669;
            cursor: pointer;
            border: none;
            box-shadow: 0 4px 8px rgba(5, 150, 105, 0.3);
            transition: all 0.2s ease;
        }

        .slider:hover {
            background: #d1d5db;
        }

        /* Modern Button Styles */
        .btn-primary {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
            color: white;
            font-weight: 700;
            padding: 0.875rem 1.75rem;
            border-radius: 12px;
            border: 2px solid transparent;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 6px -1px rgba(5, 150, 105, 0.2);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-size: var(--font-base);
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 20px -1px rgba(5, 150, 105, 0.4);
            border-color: rgba(5, 150, 105, 0.3);
        }

        .btn-primary:active {
            transform: translateY(-1px);
        }

        .btn-primary:focus {
            outline: none;
            box-shadow: 0 0 0 4px rgba(5, 150, 105, 0.2);
        }

        /* Enhanced Progress Bars */
        .progress-bar {
            background: #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
            height: 8px;
        }

        .progress-fill {
            background: linear-gradient(90deg, #059669 0%, #10b981 100%);
            height: 100%;
            border-radius: 8px;
            transition: width 0.6s ease;
        }

        /* Modern Form Elements */
        .form-input {
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            padding: 0.75rem 1rem;
            transition: all 0.2s ease;
            background: white;
        }

        .form-input:focus {
            outline: none;
            border-color: #059669;
            box-shadow: 0 0 0 3px rgba(5, 150, 105, 0.1);
        }

        .form-input:hover {
            border-color: #cbd5e1;
        }

        /* Prevent browser autocomplete styling */
        input:-webkit-autofill,
        input:-webkit-autofill:hover,
        input:-webkit-autofill:focus,
        input:-webkit-autofill:active {
            -webkit-box-shadow: 0 0 0 30px white inset !important;
            -webkit-text-fill-color: #374151 !important;
            transition: background-color 5000s ease-in-out 0s;
        }

        /* Additional autocomplete prevention - REMOVED -webkit-text-security to fix dots */
        input[autocomplete="off"] {
            background-image: none !important;
            background-color: white !important;
            -webkit-appearance: none;
        }
        
        /* Global credential prompt prevention - REMOVED -webkit-text-security to fix dots */
        form[data-form-type="other"],
        input[data-lpignore="true"] {
            -webkit-appearance: none;
            background-image: none !important;
        }

        /* Enhanced Animations */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .fade-in-up {
            animation: fadeInUp 0.6s ease-out;
        }

        /* Modern Spacing Utilities */
        .space-y-6 > * + * {
            margin-top: var(--spacing-6);
        }

        .space-y-8 > * + * {
            margin-top: var(--spacing-8);
        }

        .space-y-10 > * + * {
            margin-top: var(--spacing-10);
        }
    </style>
</head>
<body class="bg-gradient-to-br from-slate-100 to-green-50 min-h-screen">

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef, useMemo } = React;

        // Initialize Neon Database - Using the correct Daily David database
        const neonConnectionString = 'postgresql://neondb_owner:npg_L5ysD0JfHSFP@ep-little-base-adgfntzb-pooler.c-2.us-east-1.aws.neon.tech/neondb?sslmode=require&channel_binding=require';
        
        // PRODUCTION TABLE NAME
        const TABLE_NAME = 'daily_david_entries';
        
        // User management using real Neon database
        let currentUser = null;
        let isAdmin = false;

        // Neon Database Manager - Structured approach (copied from working marriage meeting tool)
        class NeonDatabaseManager {
            constructor() {
                this.isInitialized = false;
                this.neonClient = null;
                this.saveDebounceTimer = null;
                this.SAVE_DEBOUNCE_DELAY = 2000; // Increase debounce delay
            }

            async initializeNeon() {
                try {
                    // Make sure Neon client is properly loaded
                    if (window.neonClient) {
                        this.neonClient = window.neonClient;
                        this.isInitialized = true;
                        console.log('✅ [NEON] Client initialized successfully');
                        return true;
                    } else {
                        console.error('❌ [NEON] Client not found on window object');
                        return false;
                    }
                } catch (error) {
                    console.error('❌ [NEON] Initialization failed:', error);
                    return false;
                }
            }

            async executeQuery(query, params = []) {
                if (!this.isInitialized) {
                    const initialized = await this.initializeNeon();
                    if (!initialized) {
                        throw new Error('Neon client not initialized');
                    }
                }

                try {
                    console.log('🚀 [NEON] Executing query:', query);
                    console.log('🚀 [NEON] Parameters:', params);

                    // The neon client function should be called directly with the connection string and query
                    const sql = this.neonClient(neonConnectionString);
                    const result = await sql(query, params);

                    console.log('✅ [NEON] Query successful:', result);
                    console.log('🔍 [NEON] Result type:', typeof result);
                    console.log('🔍 [NEON] Result structure:', {
                        isArray: Array.isArray(result),
                        hasRows: result && result.rows,
                        length: Array.isArray(result) ? result.length : 'N/A',
                        keys: result && typeof result === 'object' ? Object.keys(result) : 'N/A'
                    });
                    return result;
                } catch (error) {
                    console.error('❌ [NEON] Query failed:', error);
                    throw error;
                }
            }

            async loadDayData(dateKey, userId) {
                try {
                    const query = `
                        SELECT data_content, updated_at 
                        FROM daily_david_entries 
                        WHERE date_key = $1 AND user_id = $2 
                        LIMIT 1
                    `;
                    
                    const result = await this.executeQuery(query, [dateKey, userId]);
                    console.log('🔍 [NEON] Raw query result:', result);
                    
                    // Handle different result structures from Neon client
                    let data;
                    if (result && Array.isArray(result) && result.length > 0) {
                        // Standard array result
                        data = result[0];
                    } else if (result && result.rows && Array.isArray(result.rows) && result.rows.length > 0) {
                        // Result with rows property
                        data = result.rows[0];
                    } else if (result && typeof result === 'object' && result.data_content) {
                        // Direct object result
                        data = result;
                    } else {
                        console.log('ℹ️ [NEON] No existing data found, returning null');
                        return null;
                    }
                    
                    if (data && data.data_content) {
                        const parsedData = typeof data.data_content === 'string' 
                            ? JSON.parse(data.data_content) 
                            : data.data_content;
                        
                        console.log('✅ [NEON] Day data loaded successfully:', parsedData);
                        return parsedData;
                    } else {
                        console.log('ℹ️ [NEON] No data_content found in result, returning empty structure');
                        return this.getEmptyDayStructure();
                    }
                } catch (error) {
                    console.error('❌ [NEON] Failed to load day data:', error);
                    throw error;
                }
            }

            async saveDayData(dateKey, userId, data) {
                try {
                    // Ensure data has the correct structure before saving
                    const validatedData = {
                        dailyIntention: data.dailyIntention || '',
                        leadershipRating: {
                            wisdom: data.leadershipRating?.wisdom || 5,
                            courage: data.leadershipRating?.courage || 5,
                            patience: data.leadershipRating?.patience || 5,
                            integrity: data.leadershipRating?.integrity || 5
                        },
                        growthQuestion: data.growthQuestion || '',
                        checkIn: {
                            emotions: data.checkIn?.emotions || [],
                            feeling: data.checkIn?.feeling || ''
                        },
                        gratitude: data.gratitude || ['', '', ''],
                        soap: {
                            scripture: data.soap?.scripture || '',
                            observation: data.soap?.observation || '',
                            application: data.soap?.application || '',
                            prayer: data.soap?.prayer || ''
                        },
                        goals: {
                            daily: data.goals?.daily || [],
                            weekly: data.goals?.weekly || [],
                            monthly: data.goals?.monthly || []
                        }
                    };
                    
                    console.log('💾 [NEON] Saving day data with structure:', {
                        dateKey,
                        userId,
                        originalData: data,
                        validatedData,
                        dailyIntention: validatedData.dailyIntention,
                        leadershipRating: validatedData.leadershipRating,
                        growthQuestion: validatedData.growthQuestion,
                        checkInEmotions: validatedData.checkIn.emotions.length,
                        gratitudeLength: validatedData.gratitude.length,
                        soapKeys: Object.keys(validatedData.soap),
                        goalsKeys: Object.keys(validatedData.goals)
                    });
                    
                    const query = `
                        INSERT INTO daily_david_entries (date_key, user_id, data_content, updated_at)
                        VALUES ($1, $2, $3, NOW())
                        ON CONFLICT (date_key, user_id)
                        DO UPDATE SET 
                            data_content = EXCLUDED.data_content,
                            updated_at = NOW()
                        RETURNING id, updated_at
                    `;

                    const jsonData = JSON.stringify(validatedData);
                    const result = await this.executeQuery(query, [dateKey, userId, jsonData]);
                    
                    console.log('✅ [NEON] Day data saved successfully:', result);
                    return result;
                } catch (error) {
                    console.error('❌ [NEON] Failed to save day data:', error);
                    throw error;
                }
            }

            debouncedSave(dateKey, userId, data, callback) {
                console.log('⏰ [DEBOUNCE] Scheduling save for:', { dateKey, userId, data });
                
                // Clear existing timer
                if (this.saveDebounceTimer) {
                    clearTimeout(this.saveDebounceTimer);
                    console.log('⏰ [DEBOUNCE] Cleared existing timer');
                }

                // Set new timer
                this.saveDebounceTimer = setTimeout(async () => {
                    console.log('⏰ [DEBOUNCE] Timer fired, executing save...');
                    try {
                        await this.saveDayData(dateKey, userId, data);
                        console.log('✅ [DEBOUNCE] Save completed successfully');
                        if (callback) callback(null, true);
                    } catch (error) {
                        console.error('❌ [DEBOUNCE] Save failed:', error);
                        if (callback) callback(error, false);
                    }
                }, this.SAVE_DEBOUNCE_DELAY);
                
                console.log('⏰ [DEBOUNCE] Timer set for', this.SAVE_DEBOUNCE_DELAY, 'ms');
            }

            getEmptyDayStructure() {
                return {
                    dailyIntention: '',
                    leadershipRating: {
                        wisdom: 5,
                        courage: 5,
                        patience: 5,
                        integrity: 5
                    },
                    growthQuestion: '',
                    checkIn: {
                        emotions: [],
                        feeling: ''
                    },
                    gratitude: ['', '', ''],
                    soap: {
                        scripture: '',
                        observation: '',
                        application: '',
                        prayer: ''
                    },
                    goals: {
                        daily: [],
                        weekly: [],
                        monthly: []
                    }
                };
            }

            async testConnection() {
                try {
                    // Ensure Neon client is initialized first
                    if (!this.isInitialized) {
                        const initialized = await this.initializeNeon();
                        if (!initialized) {
                            console.error('❌ [NEON] Failed to initialize Neon client');
                            return false;
                        }
                    }

                    // Test with a simple query
                    const result = await this.executeQuery('SELECT 1 as test');
                    console.log('✅ [NEON] Connection test successful:', result);
                    return true;
                } catch (error) {
                    console.error('❌ [NEON] Connection test failed:', error);
                    return false;
                }
            }

            // User Management Methods (copied from working marriage meeting tool)
            async createUsersTable() {
                try {
                    // First, check if the table exists and has the correct schema
                    const checkQuery = `
                        SELECT column_name, data_type 
                        FROM information_schema.columns 
                        WHERE table_name = 'users' AND column_name = 'id'
                    `;
                    
                    const checkResult = await this.executeQuery(checkQuery);
                    console.log('🔍 [NEON] Current users table schema:', checkResult);
                    
                    if (checkResult && checkResult.length > 0) {
                        const idColumn = checkResult[0];
                        if (idColumn.data_type !== 'uuid') {
                            console.log('⚠️ [NEON] Users table has wrong ID column type, recreating...');
                            
                            // Drop the existing table
                            await this.executeQuery('DROP TABLE IF EXISTS users CASCADE');
                            console.log('✅ [NEON] Dropped existing users table');
                        }
                    }
                    
                    const query = `
                        CREATE TABLE IF NOT EXISTS users (
                            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                            email VARCHAR(255) UNIQUE NOT NULL,
                            display_name VARCHAR(255) NOT NULL,
                            password_hash VARCHAR(255) NOT NULL,
                            is_admin BOOLEAN DEFAULT FALSE,
                            created_at TIMESTAMP DEFAULT NOW(),
                            updated_at TIMESTAMP DEFAULT NOW()
                        )
                    `;
                    
                    await this.executeQuery(query);
                    console.log('✅ [NEON] Users table created/verified successfully');
                    return true;
                } catch (error) {
                    console.error('❌ [NEON] Failed to create users table:', error);
                    return false;
                }
            }

            async createDailyDavidEntriesTable() {
                try {
                    const query = `
                        CREATE TABLE IF NOT EXISTS daily_david_entries (
                            id SERIAL PRIMARY KEY,
                            date_key VARCHAR(10) NOT NULL,
                            user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
                            data_content JSONB NOT NULL,
                            created_at TIMESTAMP DEFAULT NOW(),
                            updated_at TIMESTAMP DEFAULT NOW(),
                            UNIQUE(date_key, user_id)
                        )
                    `;
                    
                    await this.executeQuery(query);
                    console.log('✅ [NEON] Daily David entries table created successfully');
                    
                    // Create indexes for performance
                    await this.executeQuery('CREATE INDEX IF NOT EXISTS idx_daily_david_entries_user_date ON daily_david_entries(user_id, date_key)');
                    await this.executeQuery('CREATE INDEX IF NOT EXISTS idx_daily_david_entries_date ON daily_david_entries(date_key)');
                    
                    return true;
                } catch (error) {
                    console.error('❌ [NEON] Failed to create daily david entries table:', error);
                    return false;
                }
            }

            async createUser(email, displayName, password, isAdmin = false) {
                try {
                    // In a real app, you'd hash the password
                    // For development, we'll store it as-is (NOT recommended for production)
                    const passwordHash = password; // In production: await bcrypt.hash(password, 10)
                    
                    // Generate a UUID explicitly since DEFAULT gen_random_uuid() isn't working
                    const query = `
                        INSERT INTO users (id, email, display_name, password_hash, is_admin)
                        VALUES (gen_random_uuid(), $1, $2, $3, $4)
                        RETURNING id, email, display_name, is_admin, created_at
                    `;
                    
                    const result = await this.executeQuery(query, [email, displayName, passwordHash, isAdmin]);
                    console.log('✅ [NEON] User created successfully:', result);
                    return result;
                } catch (error) {
                    console.error('❌ [NEON] Failed to create user:', error);
                    throw error;
                }
            }

            async getAllUsers() {
                try {
                    const query = `
                        SELECT id, email, display_name, is_admin, created_at, updated_at
                        FROM users
                        ORDER BY created_at DESC
                    `;
                    
                    const result = await this.executeQuery(query);
                    console.log('✅ [NEON] Users loaded successfully:', result);
                    return result;
                } catch (error) {
                    console.error('❌ [NEON] Failed to load users:', error);
                    return [];
                }
            }

            async deleteUser(userId) {
                try {
                    const query = `
                        DELETE FROM users
                        WHERE id = $1
                        RETURNING id, email
                    `;
                    
                    const result = await this.executeQuery(query, [userId]);
                    console.log('✅ [NEON] User deleted successfully:', result);
                    return result;
                } catch (error) {
                    console.error('❌ [NEON] Failed to delete user:', error);
                    throw error;
                }
            }

            async getUserByEmail(email) {
                try {
                    const query = `
                        SELECT id, email, display_name, password_hash, is_admin, created_at
                        FROM users
                        WHERE email = $1
                        LIMIT 1
                    `;
                    
                    const result = await this.executeQuery(query, [email]);
                    console.log('✅ [NEON] User found by email:', result);
                    return result && result.length > 0 ? result[0] : null;
                } catch (error) {
                    console.error('❌ [NEON] Failed to find user by email:', error);
                    return null;
                }
            }

            // Goals management methods
            async saveGoals(userId, goalsData) {
                try {
                    // Goals are now stored as part of day data, not as separate entries
                    // This function is kept for backward compatibility but doesn't save to Neon
                    // Goals should be saved through saveDayData instead
                    console.log('ℹ️ [NEON] saveGoals called - goals are now part of day data');
                    return { data: null, error: null };
                } catch (error) {
                    console.error('❌ [NEON] Goals save error:', error);
                    return { data: null, error: error.message };
                }
            }

            async loadGoals(userId) {
                try {
                    // Goals are now stored as part of day data, not as separate entries
                    // This function is kept for backward compatibility but returns null
                    // Goals should be loaded through loadDayData instead
                    console.log('ℹ️ [NEON] loadGoals called - goals are now part of day data');
                    return null;
                } catch (error) {
                    console.error('❌ [NEON] Load goals error:', error);
                    return null;
                }
            }
        }

        // Updated React hook for managing day data (adapted from working marriage meeting tool)
        function useDayData(dateKey, userId) {
            const [dayData, setDayData] = React.useState(null);
            const [isLoading, setIsLoading] = React.useState(true);
            const [error, setError] = React.useState(null);
            const dbManager = React.useRef(new NeonDatabaseManager());
            const lastSaveData = React.useRef(null);

            // Initialize and load data
            React.useEffect(() => {
                async function initializeData() {
                    try {
                        setIsLoading(true);
                        setError(null);

                        // Test connection first
                        const connectionOk = await dbManager.current.testConnection();
                        if (!connectionOk) {
                            throw new Error('Database connection failed');
                        }

                        // Load day data from Neon database
                        const data = await dbManager.current.loadDayData(dateKey, userId);
                        console.log('🔍 [useDayData] Loaded data from Neon:', data);
                        
                        // Cross-device sync logging
                        console.log('📱 [Cross-Device Debug] useDayData loading for:', {
                            dateKey,
                            userId,
                            deviceInfo: {
                                userAgent: navigator.userAgent,
                                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                                timestamp: new Date().toISOString()
                            },
                            neonDataExists: !!data,
                            neonDataKeys: data ? Object.keys(data) : []
                        });
                        
                        // Check if we actually have meaningful data (not just empty structure)
                        const hasRealData = data && 
                            Object.keys(data).length > 0 && 
                            (data.gratitude?.some(item => item.trim() !== '') ||
                             data.soap?.scripture?.trim() !== '' ||
                             data.soap?.observation?.trim() !== '' ||
                             data.soap?.application?.trim() !== '' ||
                             data.soap?.prayer?.trim() !== '' ||
                             data.goals?.daily?.length > 0 ||
                             data.goals?.weekly?.length > 0 ||
                             data.goals?.monthly?.length > 0 ||
                             data.dailyIntention?.trim() !== '' ||
                             data.growthQuestion?.trim() !== '' ||
                             data.checkIn?.feeling?.trim() !== '' ||
                             data.checkIn?.emotions?.length > 0 ||
                             (data.leadershipRating && (
                                 data.leadershipRating.wisdom !== 5 ||
                                 data.leadershipRating.courage !== 5 ||
                                 data.leadershipRating.patience !== 5 ||
                                 data.leadershipRating.integrity !== 5
                             )));
                        
                        console.log('🔍 [useDayData] Data validation check:', {
                            hasData: !!data,
                            dataKeys: data ? Object.keys(data) : [],
                            gratitudeHasContent: data?.gratitude?.some(item => item.trim() !== ''),
                            soapHasContent: data?.soap?.scripture?.trim() !== '' || data?.soap?.observation?.trim() !== '' || data?.soap?.application?.trim() !== '' || data?.soap?.prayer?.trim() !== '',
                            goalsHaveContent: data?.goals?.daily?.length > 0 || data?.goals?.weekly?.length > 0 || data?.goals?.monthly?.length > 0,
                            dailyIntentionHasContent: data?.dailyIntention?.trim() !== '',
                            growthQuestionHasContent: data?.growthQuestion?.trim() !== '',
                            checkInHasContent: data?.checkIn?.feeling?.trim() !== '' || data?.checkIn?.emotions?.length > 0,
                            leadershipRatingHasContent: data?.leadershipRating && (
                                data?.leadershipRating.wisdom !== 5 ||
                                data?.leadershipRating.courage !== 5 ||
                                data?.leadershipRating.patience !== 5 ||
                                data?.leadershipRating.integrity !== 5
                            ),
                            hasRealData
                        });
                        
                        if (hasRealData) {
                            setDayData(data);
                            lastSaveData.current = JSON.stringify(data);
                            console.log('✅ [useDayData] Day data loaded from Neon for:', dateKey);
                        } else {
                            // No data in Neon, check localStorage as fallback
                            const localStorageKey = `dailyDavid_dayData_${userId}`;
                            const localStorageData = localStorage.getItem(localStorageKey);
                            if (localStorageData) {
                                const parsedData = JSON.parse(localStorageData);
                                if (parsedData[dateKey]) {
                                    console.log('🔄 [useDayData] Loading from localStorage fallback for:', dateKey);
                                    setDayData(parsedData[dateKey]);
                                    lastSaveData.current = JSON.stringify(parsedData[dateKey]);
                                    
                                    // Also save this data to Neon for future use
                                    try {
                                        console.log('🔄 [useDayData] Migrating localStorage data to Neon...');
                                        await dbManager.current.saveDayData(dateKey, userId, parsedData[dateKey]);
                                        console.log('✅ [useDayData] Data migrated from localStorage to Neon');
                                    } catch (saveError) {
                                        console.warn('⚠️ [useDayData] Failed to migrate localStorage data to Neon:', saveError);
                                        // Don't fail completely if migration fails, just log the warning
                                    }
                                } else {
                                    console.log('ℹ️ [useDayData] No data found in localStorage for date:', dateKey);
                                    const emptyData = dbManager.current.getEmptyDayStructure();
                                    setDayData(emptyData);
                                    lastSaveData.current = JSON.stringify(emptyData);
                                }
                            } else {
                                console.log('ℹ️ [useDayData] No localStorage data found for user:', userId);
                                const emptyData = dbManager.current.getEmptyDayStructure();
                                setDayData(emptyData);
                                lastSaveData.current = JSON.stringify(emptyData);
                            }
                        }
                        
                        console.log('✅ [useDayData] Day data initialization complete for:', dateKey);
                    } catch (err) {
                        console.error('❌ [useDayData] Day data initialization failed:', err);
                        setError(err.message);
                        // Set empty structure as fallback
                        const emptyData = dbManager.current.getEmptyDayStructure();
                        setDayData(emptyData);
                        lastSaveData.current = JSON.stringify(emptyData);
                    } finally {
                        setIsLoading(false);
                    }
                }

                console.log('🔍 useDayData useEffect - dateKey:', dateKey, 'userId:', userId);
                
                if (dateKey && userId) {
                    console.log('🔍 useDayData - Initializing data with userId:', userId);
                    initializeData();
                } else {
                    console.log('🔍 useDayData - Skipping initialization, missing dateKey or userId');
                    // Set empty structure when no user
                    const emptyData = dbManager.current.getEmptyDayStructure();
                    setDayData(emptyData);
                    lastSaveData.current = JSON.stringify(emptyData);
                    setIsLoading(false);
                }
            }, [dateKey, userId]);

            // Auto-save functionality with improved debouncing
            React.useEffect(() => {
                if (!dayData || isLoading || !userId) return;

                const currentDataString = JSON.stringify(dayData);
                
                // Only save if data has actually changed
                if (currentDataString !== lastSaveData.current) {
                    console.log('🔄 [AUTO-SAVE] Day data changed, scheduling save...');
                    console.log('🔄 [AUTO-SAVE] Data to save:', dayData);
                    console.log('🔄 [AUTO-SAVE] Date key:', dateKey);
                    console.log('🔄 [AUTO-SAVE] User ID:', userId);
                    
                    dbManager.current.debouncedSave(dateKey, userId, dayData, (error, success) => {
                        if (success) {
                            lastSaveData.current = currentDataString;
                            console.log('✅ [AUTO-SAVE] Day data saved successfully');
                        } else {
                            console.error('❌ [AUTO-SAVE] Day data save failed:', error);
                            setError('Auto-save failed');
                        }
                    });
                }
            }, [dayData, dateKey, userId, isLoading]);

            const updateDayData = React.useCallback((updater) => {
                setDayData(prevData => {
                    if (typeof updater === 'function') {
                        return updater(prevData);
                    } else {
                        return { ...prevData, ...updater };
                    }
                });
            }, []);

            const manualSave = React.useCallback(async (onSuccess) => {
                try {
                    console.log('🔧 [MANUAL-SAVE] Starting manual save...');
                    console.log('🔧 [MANUAL-SAVE] Data to save:', dayData);
                    console.log('🔧 [MANUAL-SAVE] Date key:', dateKey);
                    console.log('🔧 [MANUAL-SAVE] User ID:', userId);
                    
                    await dbManager.current.saveDayData(dateKey, userId, dayData);
                    lastSaveData.current = JSON.stringify(dayData);
                    console.log('✅ [MANUAL-SAVE] Day data saved successfully');
                    if (onSuccess) onSuccess();
                    return true;
                } catch (error) {
                    console.error('❌ [MANUAL-SAVE] Save failed:', error);
                    setError('Manual save failed');
                    return false;
                }
            }, [dateKey, userId, dayData]);

            return {
                dayData,
                setDayData: updateDayData,
                isLoading,
                error,
                manualSave
            };
        }

        // Initialize the Neon database manager
        const neonDB = new NeonDatabaseManager();

        // Icons as SVG components
        const ChevronLeftIcon = () => (
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
            </svg>
        );

        const ChevronRightIcon = () => (
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
            </svg>
        );

        const PlusIcon = () => (
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
            </svg>
        );

                // Authentication Components (copied from working marriage meeting tool)
        const SignInScreen = ({ onSignIn, onAdminSignIn }) => {
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState('');

            const handleSignIn = async (e) => {
                e.preventDefault();
                setLoading(true);
                setError('');

                try {
                    // Real authentication with database users (copied from working marriage meeting tool)
                    console.log('🔐 Attempting real authentication...');
                    
                    // Check if user exists in database
                    const dbManager = new NeonDatabaseManager();
                    
                    // Explicitly query for user with password_hash
                    const query = `
                        SELECT id, email, display_name, password_hash, is_admin, created_at
                        FROM users
                        WHERE email = $1
                        LIMIT 1
                    `;
                    const result = await dbManager.executeQuery(query, [email]);
                    const dbUser = result && result.length > 0 ? result[0] : null;
                    
                    if (!dbUser) {
                        throw new Error('User not found. Please contact an admin to create your account.');
                    }
                    
                    console.log('🔍 Password check:', {
                        provided: password,
                        stored: dbUser.password_hash,
                        match: dbUser.password_hash === password
                    });
                    
                    // In a real app, you'd verify the password hash
                    // For development, we'll just check if password matches (NOT secure for production)
                    if (dbUser.password_hash !== password) {
                        throw new Error(`Invalid password. Expected: ${dbUser.password_hash}, Got: ${password}`);
                    }
                    
                    // Create user object from database user
                    const authenticatedUser = {
                        id: dbUser.id,
                        email: dbUser.email,
                        display_name: dbUser.display_name,
                        is_admin: dbUser.is_admin,
                        user_metadata: { is_admin: dbUser.is_admin }
                    };
                    
                    console.log('✅ User authenticated:', authenticatedUser.email);
                    console.log('🔍 User ID from database:', dbUser.id, 'Type:', typeof dbUser.id);
                    console.log('🔍 Full dbUser object:', dbUser);
                    
                    // Set the global currentUser variable for getCurrentUserId() to work
                    window.currentAuthenticatedUser = authenticatedUser;
                    
                    // Store authentication in localStorage for persistence
                    const authData = {
                        user: authenticatedUser,
                        timestamp: Date.now()
                    };
                    localStorage.setItem('dailyDavidAuth', JSON.stringify(authData));
                    console.log('💾 Authentication stored in localStorage');
                    
                    if (authenticatedUser.is_admin) {
                        onAdminSignIn(authenticatedUser);
                    } else {
                        onSignIn(authenticatedUser);
                    }
                } catch (error) {
                    setError(error.message);
                } finally {
                    setLoading(false);
                }
            };

            return (
                <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-slate-100 to-green-50">
                    <div className="modern-card p-8 w-full max-w-md">
                        <h1 className="text-3xl font-bold text-center mb-8 text-primary">
                            The Daily David
                        </h1>
                        <p className="text-center text-gray-600 mb-6">Sign in to access your spiritual growth journey</p>
                        
                        {error && (
                            <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
                                {error}
                            </div>
                        )}
                        
                        <form onSubmit={handleSignIn} className="space-y-4" autoComplete="off" data-form-type="other" data-lpignore="true">
                            <input 
                                type="email" 
                                placeholder="Email" 
                                className="w-full p-3 border rounded-lg focus:ring-2 focus:ring-primary focus:border-transparent"
                                value={email}
                                onChange={(e) => setEmail(e.target.value)}
                                required
                                autoComplete="off"
                                data-lpignore="true"
                                data-form-type="other"
                                data-1p-ignore="true"
                                data-bwignore="true"
                                data-akignore="true"
                                data-dashlane-rid="ignore"
                            />
                            <input 
                                type="password" 
                                placeholder="Password" 
                                className="w-full p-3 border rounded-lg focus:ring-2 focus:ring-primary focus:border-transparent"
                                value={password}
                                onChange={(e) => setPassword(e.target.value)}
                                required
                                autoComplete="off"
                                data-lpignore="true"
                                data-form-type="other"
                                data-1p-ignore="true"
                                data-bwignore="true"
                                data-akignore="true"
                                data-dashlane-rid="ignore"
                            />
                            <button 
                                type="submit"
                                disabled={loading}
                                className="w-full bg-primary text-white py-3 rounded-lg hover:bg-primary/90 disabled:opacity-50 disabled:cursor-not-allowed"
                            >
                                {loading ? 'Signing In...' : 'Sign In'}
                            </button>
                        </form>
                        
                        <div className="mt-6 text-center">
                            <p className="text-sm text-gray-500">
                                Contact your administrator for access
                            </p>
                        </div>
                    </div>
                </div>
            );
        };

        // Get the current user ID (copied from working marriage meeting tool)
        const getCurrentUserId = () => {
            console.log('🔍 getCurrentUserId called');
            console.log('🔍 window.currentAuthenticatedUser:', window.currentAuthenticatedUser);
            
            if (window.currentAuthenticatedUser && window.currentAuthenticatedUser.id) {
                console.log('🔍 Returning authenticated user ID:', window.currentAuthenticatedUser.id);
                return window.currentAuthenticatedUser.id;
            }
            // Return null if no authenticated user (no fallback to dev user ID)
            console.log('🔍 No authenticated user, returning null');
            return null;
        };

        const AdminPanel = ({ user, onSignOut, onAddUser, onRemoveUser, useServiceRoleKey }) => {
            const [users, setUsers] = useState([]);
            const [newUserEmail, setNewUserEmail] = useState('');
            const [newUserPassword, setNewUserPassword] = useState('');
            const [newUserDisplayName, setNewUserDisplayName] = useState('');
            const [loading, setLoading] = useState(false);

            useEffect(() => {
                loadUsers();
            }, []);

            // CREDENTIAL PREVENTION TEMPORARILY DISABLED TO FIX DOTS ISSUE
            // useEffect(() => {
            //     const adminPanel = document.querySelector('[data-admin-panel="true"]');
            //     if (adminPanel) {
            //         const inputs = adminPanel.querySelectorAll('input[type="email"], input[type="password"]');
            //         inputs.forEach(input => {
            //             input.setAttribute('data-lpignore', 'true');
            //             input.setAttribute('data-form-type', 'other');
            //             input.setAttribute('data-1p-ignore', 'true');
            //             input.setAttribute('data-bwignore', 'true');
            //             input.setAttribute('data-akignore', 'true');
            //             input.setAttribute('data-dashlane-rid', 'ignore');
            //     });
            //     }
            // }, []);

            // CREDENTIAL PREVENTION TEMPORARILY DISABLED TO FIX DOTS ISSUE
            // useEffect(() => {
            //     const adminPanel = document.querySelector('[data-admin-panel="true"]');
            //     if (adminPanel) {
            //         const inputs = adminPanel.querySelectorAll('input[type="email"], input[type="password"]');
            //         inputs.forEach(input => {
            //             input.setAttribute('autocomplete', 'new-password');
            //             input.setAttribute('data-lpignore', 'true');
            //             input.setAttribute('data-1p-ignore', 'true');
            //             input.setAttribute('data-form-type', 'other');
            //     });
            //     }
            // }, []);

            const loadUsers = async () => {
                try {
                    console.log('Loading users from Neon database...');
                    console.log('🔍 Current user:', user);
                    console.log('🔍 Is admin:', isAdmin);
                    
                    // Load users from real Neon database (copied from working marriage meeting tool)
                    const dbManager = new NeonDatabaseManager();
                    const result = await dbManager.getAllUsers();
                    
                    if (result && Array.isArray(result)) {
                        setUsers(result);
                        console.log('✅ Users loaded from database:', result);
                    } else {
                        console.log('⚠️ No users found in database, using fallback');
                        setUsers([]);
                    }
                } catch (error) {
                    console.error('❌ Error loading users:', error);
                    setUsers([]);
                }
            };

            const handleAddUser = async (e) => {
                e.preventDefault();
                
                // Prevent credential prompts
                e.target.querySelectorAll('input').forEach(input => {
                    input.setAttribute('data-lpignore', 'true');
                    input.setAttribute('data-form-type', 'other');
                });
                
                if (!newUserEmail || !newUserPassword || !newUserDisplayName) return;

                setLoading(true);
                try {
                    // Create user in database (copied from working marriage meeting tool)
                    const dbManager = new NeonDatabaseManager();
                    console.log('🔄 Creating user in database:', { email: newUserEmail, displayName: newUserDisplayName, isAdmin: false });
                    
                    const newUser = await dbManager.createUser(newUserEmail, newUserDisplayName, newUserPassword, false);
                    console.log('📊 New user result:', newUser);
                    
                    if (newUser && newUser.length > 0) {
                        // Add to local state
                        setUsers(prevUsers => [newUser[0], ...prevUsers]);
                        
                        // Show success message
                        alert(`✅ User created successfully!\n\nEmail: ${newUserEmail}\nDisplay Name: ${newUserDisplayName}\n\nUser ID: ${newUser[0].id}`);
                        
                        // Reset form
                        setNewUserEmail('');
                        setNewUserPassword('');
                        setNewUserDisplayName('');
                        
                        console.log('✅ User added to local state, total users:', users.length + 1);
                    } else {
                        throw new Error('User creation returned empty result');
                    }
                } catch (error) {
                    console.error('❌ Failed to create user:', error);
                    alert(`❌ Failed to create user:\n\n${error.message}`);
                } finally {
                    setLoading(false);
                }
            };

            return (
                <div className="container mx-auto px-4 py-8 max-w-6xl" data-admin-panel="true">
                    <div className="flex justify-between items-center mb-8">
                        <h1 className="text-3xl font-bold text-gray-800">Admin Panel</h1>
                        <div className="flex items-center gap-3">
                            <button 
                                onClick={onSignOut}
                                className="bg-red-500 text-white px-4 py-2 rounded-lg hover:bg-red-600"
                            >
                                Sign Out
                            </button>
                        </div>
                    </div>

                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                        {/* User Management */}
                        <div className="modern-card p-6">
                            <h2 className="text-2xl font-bold mb-4 text-primary">User Management</h2>
                            
                            {/* Service Role Key Notice - Only show if not configured */}
                            {!useServiceRoleKey && (
                                <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-6">
                                    <div className="flex items-center gap-2">
                                        <span className="text-yellow-800">⚠️</span>
                                        <div>
                                            <p className="text-yellow-800 font-medium">Admin Functions Setup Required</p>
                                            <p className="text-yellow-700 text-sm">
                                                To use admin functions (create/delete users), you need to:
                                            </p>
                                            <ol className="text-yellow-700 text-sm mt-2 list-decimal list-inside space-y-1">
                                                <li>Go to Supabase Dashboard → Settings → API</li>
                                                <li>Copy your "service_role" key</li>
                                                <li>Replace "YOUR_SERVICE_ROLE_KEY_HERE" in the code</li>
                                                <li>Set USE_SERVICE_ROLE_KEY = true</li>
                                            </ol>
                                            <p className="text-yellow-700 text-sm mt-2">
                                                <strong>Note:</strong> Service role keys have full database access - only use for development/testing.
                                            </p>
                                        </div>
                                    </div>
                                </div>
                            )}
                            
                            {/* Success Message - Show when service role key is configured */}
                            {useServiceRoleKey && (
                                <div className="bg-green-50 border border-green-200 rounded-lg p-4 mb-6">
                                    <div className="flex items-center gap-2">
                                        <span className="text-green-800">✅</span>
                                        <div>
                                            <p className="text-green-800 font-medium">Admin Functions Enabled!</p>
                                            <p className="text-green-700 text-sm">
                                                Service role key is configured. You can now create, manage, and delete users through this panel.
                                            </p>
                                        </div>
                                    </div>
                                </div>
                            )}
                            
                            <form onSubmit={handleAddUser} className="space-y-4 mb-6" autoComplete="off" data-form-type="other">
                                <input 
                                    type="email" 
                                    placeholder="User Email" 
                                    className="w-full p-3 border rounded-lg"
                                    value={newUserEmail}
                                    onChange={(e) => setNewUserEmail(e.target.value)}
                                    required
                                    autoComplete="off"
                                />
                                <input 
                                    type="text" 
                                    placeholder="Display Name" 
                                    className="w-full p-3 border rounded-lg"
                                    value={newUserDisplayName}
                                    onChange={(e) => setNewUserDisplayName(e.target.value)}
                                    required
                                    autoComplete="off"
                                />
                                <input 
                                    type="text" 
                                    placeholder="Password" 
                                    className="w-full p-3 border rounded-lg"
                                    value={newUserPassword}
                                    onChange={(e) => setNewUserEmail(e.target.value)}
                                    required
                                    autoComplete="off"
                                    onFocus={(e) => e.target.type = 'password'}
                                    onBlur={(e) => e.target.type = 'text'}
                                />
                                <button 
                                    type="submit"
                                    disabled={loading}
                                    className="w-full bg-primary text-white py-3 rounded-lg hover:bg-primary/90 disabled:opacity-50"
                                >
                                    {loading ? 'Adding User...' : 'Add User'}
                                </button>
                            </form>

                            <div className="space-y-2">
                                <div className="flex justify-between items-center">
                                    <h3 className="font-semibold">Current Users:</h3>
                                    <button 
                                        onClick={loadUsers}
                                        className="px-3 py-1 bg-blue-500 text-white text-sm rounded-lg hover:bg-blue-600"
                                    >
                                        🔄 Refresh
                                    </button>
                                </div>
                                
                                {users.length === 0 ? (
                                    <div className="text-center py-4 text-gray-500">
                                        No users found. Click refresh to load users.
                                    </div>
                                ) : (
                                    users.map(user => (
                                        <div key={user.id} className="flex justify-between items-center p-3 bg-gray-50 rounded-lg">
                                            <div>
                                                <div className="font-medium">{user.display_name}</div>
                                                <div className="text-sm text-gray-600">{user.email}</div>
                                            </div>
                                            <button 
                                                onClick={() => onRemoveUser(user.id)}
                                                className="text-red-500 hover:text-red-700"
                                            >
                                                Remove
                                            </button>
                                        </div>
                                    ))
                                )}
                            </div>
                        </div>

                        {/* System Info */}
                        <div className="modern-card p-6">
                            <h2 className="text-2xl font-bold mb-4 text-primary">System Information</h2>
                            <div className="space-y-3">
                                <div>
                                    <span className="font-medium">Admin User:</span> {user.email}
                                </div>
                                    <span className="font-medium">Total Users:</span> {users.length}
                                <div>
                                    <span className="font-medium">Environment:</span> Development
                                </div>
                                <div>
                                    <span className="font-medium">Database:</span> {TABLE_NAME}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const BookOpenIcon = () => (
            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
            </svg>
        );

        const HeartIcon = () => (
            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z" />
            </svg>
        );

        // Landing Page Component
        const LandingPage = ({ weeklyGoals, monthlyGoals, toggleGoal, addGoal, removeGoal, updateGoal, getWeeklyProgress, getMonthlyProgress, getDaysCompletedThisWeek, getCompletionRate, getCurrentStreak, getWeeklySummary, getHabitStrength, setCurrentView, forceRefreshFromNeon }) => {
            const [newGoalText, setNewGoalText] = useState('');
            const [newGoalCategory, setNewGoalCategory] = useState('spiritual');
            const [showAddGoal, setShowAddGoal] = useState(false);
            const [editingWeeklyGoal, setEditingWeeklyGoal] = useState(null);
            const [editingMonthlyGoal, setEditingMonthlyGoal] = useState(null);
            const [editWeeklyForm, setEditWeeklyForm] = useState({ text: '', category: 'spiritual' });
            const [editMonthlyForm, setEditMonthlyForm] = useState({ text: '', category: 'spiritual' });

            // Icon components for the landing page
            const TrashIcon = () => (
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                </svg>
            );

            const weeklyProgress = getWeeklyProgress();
            const monthlyProgress = getMonthlyProgress();
            const daysCompleted = getDaysCompletedThisWeek();

            const handleAddGoal = (type) => {
                if (newGoalText.trim()) {
                    addGoal(type, newGoalText.trim(), newGoalCategory);
                    setNewGoalText('');
                    setShowAddGoal(false);
                }
            };

            return (
                <div className="container mx-auto px-4 py-8 max-w-6xl">
                    {/* Header */}
                    <div className="text-center mb-8">
                        <h1 className="text-4xl font-bold text-gray-800 mb-2">
                            Welcome to Your Spiritual Journey
                        </h1>
                        <p className="text-gray-600">Track your progress and stay focused on your goals</p>
                        
                        {/* Neon Database Test Button */}
                        <div className="mt-4 mb-6">
                            <button
                                onClick={async () => {
                                    try {
                                        console.log('🧪 Testing Neon connection...');
                                        const dbManager = new NeonDatabaseManager();
        const success = await dbManager.initializeNeon();
                                        if (success) {
                                            alert('✅ Neon connection successful! Check console for details.');
                                        } else {
                                            alert('❌ Neon connection failed! Check console for details.');
                                        }
                                    } catch (error) {
                                        console.error('❌ Neon test error:', error);
                                        alert('❌ Neon test error: ' + error.message);
                                    }
                                }}
                                className="bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg transition-colors font-medium"
                            >
                                🧪 Test Neon Database
                            </button>
                        </div>
                        
                        {/* Enhanced Quick Stats */}
                        <div className="flex justify-center mb-4">
                            <button
                                onClick={forceRefreshFromNeon}
                                className="bg-blue-600 hover:bg-blue-700 text-white px-6 py-2 rounded-lg transition-colors font-medium flex items-center gap-2"
                                title="Refresh data from database for cross-device sync"
                            >
                                🔄 Sync Data
                            </button>
                        </div>
                        
                        <div className="grid grid-cols-1 md:grid-cols-4 gap-6 mt-8">
                            <div className="bg-white p-6 rounded-xl shadow-lg border-2 border-gray-200 hover:shadow-2xl hover:border-primary transition-all duration-300 transform hover:-translate-y-2">
                                <div className="text-4xl font-bold text-primary mb-3">
                                    {daysCompleted !== undefined ? `${daysCompleted}/7` : '...'}
                                </div>
                                <div className="text-base font-semibold text-gray-700 uppercase tracking-wide">Days This Week</div>
                                <div className="w-16 h-1.5 bg-primary rounded-full mt-4"></div>
                            </div>
                            <div className="bg-white p-6 rounded-xl shadow-lg border-2 border-gray-200 hover:shadow-2xl hover:border-primary transition-all duration-300 transform hover:-translate-y-2">
                                <div className="text-4xl font-bold text-primary mb-3">
                                    {weeklyProgress?.percentage !== undefined ? `${weeklyProgress.percentage}%` : '...'}
                                </div>
                                <div className="text-base font-semibold text-gray-700 uppercase tracking-wide">Weekly Goals</div>
                                <div className="w-16 h-1.5 bg-primary rounded-full mt-4"></div>
                            </div>
                            <div className="bg-white p-6 rounded-xl shadow-lg border-2 border-gray-200 hover:shadow-2xl hover:border-primary transition-all duration-300 transform hover:-translate-y-2">
                                <div className="text-4xl font-bold text-primary mb-3">
                                    {monthlyProgress?.percentage !== undefined ? `${monthlyProgress.percentage}%` : '...'}
                                </div>
                                <div className="text-base font-semibold text-gray-700 uppercase tracking-wide">Monthly Goals</div>
                                <div className="w-16 h-1.5 bg-primary rounded-full mt-4"></div>
                            </div>
                            <div className="bg-white p-6 rounded-xl shadow-lg border-2 border-gray-200 hover:shadow-2xl hover:border-green-600 transition-all duration-300 transform hover:-translate-y-2">
                                <div className="text-4xl font-bold text-green-600 mb-3">
                                    {getCurrentStreak()?.current !== undefined ? `${getCurrentStreak().current} 🔥` : '...'}
                                </div>
                                <div className="text-base font-semibold text-gray-700 uppercase tracking-wide">Current Streak</div>
                                <div className="w-16 h-1.5 bg-green-600 rounded-full mt-4"></div>
                            </div>
                        </div>
                    </div>

                    {/* Enhanced Dashboard Sections */}
                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-12">
                        {/* Completion Rate & Habit Strength */}
                        <div className="modern-card p-8">
                            <h2 className="text-2xl font-semibold text-gray-800 mb-6">⚔️ Completion & Habits</h2>
                            
                            {/* Overall Completion Rate */}
                            <div className="mb-8">
                                <div className="flex justify-between items-center mb-3">
                                    <span className="text-base font-medium text-gray-700">Overall Completion</span>
                                    <span className="text-3xl font-bold text-primary">
                                        {getCompletionRate()?.overall !== undefined ? `${getCompletionRate().overall}%` : '...'}
                                    </span>
                                </div>
                                <div className="w-full bg-gray-200 rounded-full h-4 progress-bar">
                                    <div 
                                        className="progress-fill h-4 rounded-full"
                                        style={{ width: `${getCompletionRate()?.overall !== undefined ? getCompletionRate().overall : 0}%` }}
                                    ></div>
                                </div>
                            </div>

                            {/* Habit Strength */}
                            <div className="mb-6">
                                <div className="flex justify-between items-center mb-3">
                                    <span className="text-base font-medium text-gray-700">Habit Strength</span>
                                    <span className="text-xl font-semibold text-green-600">
                                        {getHabitStrength()?.category !== undefined ? getHabitStrength().category : '...'}
                                    </span>
                                </div>
                                <div className="text-4xl font-bold text-green-600 mb-2">
                                    {getHabitStrength()?.overall !== undefined ? `${getHabitStrength().overall}/100` : '...'}
                                </div>
                                <div className="w-16 h-1 bg-green-200 rounded-full"></div>
                            </div>

                            {/* Section Breakdown */}
                            <div className="space-y-4">
                                <h4 className="text-base font-semibold text-gray-800 mb-4">Section Performance</h4>
                                {Object.entries(getCompletionRate()?.sections || {}).map(([section, percentage]) => {
                                    // Create human-readable labels for each section
                                    const sectionLabels = {
                                        dailyIntention: 'Daily Intention',
                                        leadershipRating: 'Leadership Rating',
                                        growthQuestion: 'Growth Question',
                                        checkIn: 'Check In',
                                        gratitude: 'Gratitude',
                                        soap: 'SOAP',
                                        dailyGoals: 'Daily Goals'
                                    };
                                    
                                    return (
                                        <div key={section} className="flex justify-between items-center p-3 bg-gray-50 rounded-lg hover:bg-gray-100 transition-colors">
                                            <span className="text-sm font-medium text-gray-700">{sectionLabels[section] || section}</span>
                                            <div className="flex items-center space-x-3">
                                                <div className="w-20 bg-gray-200 rounded-full h-3 progress-bar">
                                                    <div 
                                                        className={`progress-fill h-3 rounded-full transition-all duration-500 ${
                                                            percentage >= 80 ? 'bg-green-500' : 
                                                            percentage >= 60 ? 'bg-yellow-500' : 'bg-red-500'
                                                        }`}
                                                        style={{ width: `${percentage}%` }}
                                                    ></div>
                                                </div>
                                                <span className="text-sm font-semibold text-gray-700 w-12 text-right">{percentage}%</span>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>

                        {/* Weekly Summary & Insights */}
                        <div className="modern-card p-8">
                            <h2 className="text-2xl font-semibold text-gray-800 mb-6">🛡️ This Week's Insights</h2>
                            
                            {/* MVP Day */}
                            <div className="mb-8 p-4 bg-gradient-to-r from-yellow-50 to-orange-50 rounded-xl border border-yellow-200">
                                <div className="flex items-center space-x-4 mb-3">
                                    <span className="text-3xl">⚡</span>
                                    <div>
                                        <div className="text-sm font-medium text-gray-600">Most Productive Day</div>
                                        <div className="text-2xl font-bold text-primary">
                                            {getWeeklySummary()?.mvp !== undefined ? getWeeklySummary().mvp : '...'}
                                        </div>
                                    </div>
                                </div>
                                <div className="text-sm text-gray-600 ml-16">
                                    Completion Rate: <span className="font-semibold text-primary">
                                        {getWeeklySummary()?.completionRate !== undefined ? `${getWeeklySummary().completionRate}%` : '...'}
                                    </span>
                                </div>
                            </div>

                            {/* Pattern Recognition */}
                            <div className="mb-8 p-4 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-xl border border-blue-200">
                                <div className="flex items-center space-x-4 mb-3">
                                    <span className="text-3xl">🎯</span>
                                    <div>
                                        <div className="text-sm font-medium text-gray-600">Pattern Recognition</div>
                                        <div className="text-xl font-semibold text-green-600">
                                            {getWeeklySummary()?.pattern !== undefined ? getWeeklySummary().pattern : '...'}
                                        </div>
                                    </div>
                                </div>
                            </div>

                            {/* Streak Information */}
                            <div className="mb-6 p-4 bg-gradient-to-r from-orange-50 to-amber-50 rounded-xl border border-orange-200">
                                <div className="flex items-center space-x-4 mb-3">
                                    <span className="text-3xl">🔥</span>
                                    <div>
                                        <div className="text-sm font-medium text-gray-600">Streak Information</div>
                                        <div className="text-xl font-semibold text-green-600">
                                            Current: <span className="text-orange-600">{getCurrentStreak()?.current || 0}</span> | Best: <span className="text-orange-600">{getCurrentStreak()?.best || 0}</span>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            {/* Quick Actions */}
                            <div className="pt-6 border-t border-gray-200">
                                <button
                                    onClick={() => {
                                        setCurrentView('daily');
                                        // Scroll to CHECK IN section after a short delay to ensure the view has loaded
                                        setTimeout(() => {
                                            const checkInSection = document.querySelector('[data-section="check-in"]');
                                            if (checkInSection) {
                                                checkInSection.scrollIntoView({ 
                                                    behavior: 'smooth', 
                                                    block: 'start' 
                                                });
                                                // Add a subtle highlight effect
                                                checkInSection.classList.add('ring-2', 'ring-primary', 'ring-opacity-50');
                                                setTimeout(() => {
                                                    checkInSection.classList.remove('ring-2', 'ring-primary', 'ring-opacity-50');
                                                }, 2000);
                                            }
                                        }, 100);
                                    }}
                                    className="w-full btn-primary py-3 px-6 text-lg font-semibold"
                                >
                                    Start Today's Entry
                                </button>
                            </div>
                        </div>
                    </div>

                    {/* Weekly Goals Section */}
                    <div className="modern-card p-6 mb-8">
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-2xl font-semibold text-gray-800">Weekly Goals</h2>
                            <button
                                onClick={() => setShowAddGoal('weekly')}
                                className="bg-primary hover:bg-green-700 text-white px-4 py-2 rounded-md transition-colors"
                            >
                                Add Goal
                            </button>
                        </div>
                        
                        {/* Progress Bar */}
                        <div className="mb-4">
                            <div className="flex justify-between text-sm text-gray-600 mb-1">
                                <span>Progress</span>
                                <span>{weeklyProgress.completed}/{weeklyProgress.total}</span>
                            </div>
                            <div className="w-full bg-gray-200 rounded-full h-2">
                                <div 
                                    className="bg-primary h-2 rounded-full transition-all duration-300"
                                    style={{ width: `${weeklyProgress.percentage}%` }}
                                ></div>
                            </div>
                        </div>

                        {/* Goals List */}
                        <div className="space-y-3">
                            {weeklyGoals.map(goal => (
                                <div key={goal.id} className="flex items-center space-x-3 p-3 bg-gray-50 rounded-lg group">
                                    <button
                                        onClick={() => toggleGoal('weekly', goal.id)}
                                        className={`w-5 h-5 rounded-full border-2 flex items-center justify-center transition-colors ${
                                            goal.completed 
                                                ? 'bg-primary border-primary text-white' 
                                                : 'border-gray-300 hover:border-primary'
                                        }`}
                                    >
                                        {goal.completed && '✓'}
                                    </button>
                                    {editingWeeklyGoal === goal.id ? (
                                        // Edit Mode
                                        <div className="flex-1 flex space-x-2">
                                            <input
                                                type="text"
                                                value={editWeeklyForm.text}
                                                onChange={(e) => setEditWeeklyForm(prev => ({ ...prev, text: e.target.value }))}
                                                className="flex-1 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-primary"
                                                placeholder="Enter goal text..."
                                            />
                                            <select
                                                value={editWeeklyForm.category}
                                                onChange={(e) => setEditWeeklyForm(prev => ({ ...prev, category: e.target.value }))}
                                                className="px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-primary"
                                            >
                                                <option value="spiritual">Spiritual</option>
                                                <option value="personal">Personal</option>
                                                <option value="outreach">Outreach</option>
                                                <option value="health">Health</option>
                                                <option value="work">Work</option>
                                            </select>
                                            <button
                                                onClick={() => {
                                                    updateGoal('weekly', goal.id, editWeeklyForm.text, editWeeklyForm.category);
                                                    setEditingWeeklyGoal(null);
                                                    setEditWeeklyForm({ text: '', category: 'spiritual' });
                                                }}
                                                className="px-2 py-1 text-xs bg-green-500 text-white rounded hover:bg-green-600"
                                            >
                                                Save
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setEditingWeeklyGoal(null);
                                                    setEditWeeklyForm({ text: '', category: 'spiritual' });
                                                }}
                                                className="px-2 py-1 text-xs bg-gray-500 text-white rounded hover:bg-gray-600"
                                            >
                                                Cancel
                                            </button>
                                        </div>
                                    ) : (
                                        // Display Mode
                                        <>
                                            <span className={`flex-1 ${goal.completed ? 'line-through text-gray-500' : ''}`}>
                                                {goal.text}
                                            </span>
                                            <span className={`px-2 py-1 text-xs rounded-full ${
                                                goal.category === 'spiritual' ? 'bg-blue-100 text-blue-800' :
                                                goal.category === 'personal' ? 'bg-green-100 text-green-800' :
                                                'bg-purple-100 text-purple-800'
                                            }`}>
                                                {goal.category}
                                            </span>
                                        </>
                                    )}
                                    <div className="flex space-x-1 opacity-0 group-hover:opacity-100 transition-opacity">
                                        <button
                                            onClick={() => {
                                                setEditingWeeklyGoal(goal.id);
                                                setEditWeeklyForm({ text: goal.text, category: goal.category || 'spiritual' });
                                            }}
                                            className="text-blue-500 hover:text-blue-700 p-1 rounded-full hover:bg-blue-50"
                                            title="Edit goal"
                                        >
                                            ✏️
                                        </button>
                                        <button
                                            onClick={() => removeGoal('weekly', goal.id)}
                                            className="text-red-500 hover:text-red-700 p-1 rounded-full hover:bg-red-50"
                                            title="Remove goal"
                                        >
                                            <TrashIcon />
                                        </button>
                                    </div>
                                </div>
                            ))}
                        </div>

                        {/* Add Goal Form */}
                        {showAddGoal === 'weekly' && (
                            <div className="mt-4 p-4 bg-gray-50 rounded-lg">
                                <div className="flex space-x-2">
                                    <input
                                        type="text"
                                        value={newGoalText}
                                        onChange={(e) => setNewGoalText(e.target.value)}
                                        placeholder="Enter your weekly goal..."
                                        className="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary"
                                    />
                                    <select
                                        value={newGoalCategory}
                                        onChange={(e) => setNewGoalCategory(e.target.value)}
                                        className="px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary"
                                    >
                                        <option value="spiritual">Spiritual</option>
                                        <option value="personal">Personal</option>
                                        <option value="outreach">Outreach</option>
                                    </select>
                                    <button
                                        onClick={() => handleAddGoal('weekly')}
                                        className="bg-primary hover:bg-green-700 text-white px-4 py-2 rounded-md transition-colors"
                                    >
                                        Add
                                    </button>
                                    <button
                                        onClick={() => setShowAddGoal(false)}
                                        className="px-4 py-2 text-gray-600 border border-gray-300 rounded-md hover:bg-gray-50 transition-colors"
                                    >
                                        Cancel
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>

                    {/* Monthly Goals Section */}
                    <div className="modern-card p-6 mb-8">
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-2xl font-semibold text-gray-800">Monthly Goals</h2>
                            <button
                                onClick={() => setShowAddGoal('monthly')}
                                className="bg-primary hover:bg-green-700 text-white px-4 py-2 rounded-md transition-colors"
                            >
                                Add Goal
                            </button>
                        </div>
                        
                        {/* Progress Bar */}
                        <div className="mb-4">
                            <div className="flex justify-between text-sm text-gray-600 mb-1">
                                <span>Progress</span>
                                <span>{monthlyProgress.completed}/{monthlyProgress.total}</span>
                            </div>
                            <div className="w-full bg-gray-200 rounded-full h-2">
                                <div 
                                    className="bg-primary h-2 rounded-full transition-all duration-300"
                                    style={{ width: `${monthlyProgress.percentage}%` }}
                                ></div>
                            </div>
                        </div>

                        {/* Goals List */}
                        <div className="space-y-3">
                            {monthlyGoals.map(goal => (
                                <div key={goal.id} className="flex items-center space-x-3 p-3 bg-gray-50 rounded-lg group">
                                    <button
                                        onClick={() => toggleGoal('monthly', goal.id)}
                                        className={`w-5 h-5 rounded-full border-2 flex items-center justify-center transition-colors ${
                                            goal.completed 
                                                ? 'bg-primary border-primary text-white' 
                                                : 'border-gray-300 hover:border-primary'
                                        }`}
                                    >
                                        {goal.completed && '✓'}
                                    </button>
                                    {editingMonthlyGoal === goal.id ? (
                                        // Edit Mode
                                        <div className="flex-1 flex space-x-2">
                                            <input
                                                type="text"
                                                value={editMonthlyForm.text}
                                                onChange={(e) => setEditMonthlyForm(prev => ({ ...prev, text: e.target.value }))}
                                                className="flex-1 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-primary"
                                                placeholder="Enter goal text..."
                                            />
                                            <select
                                                value={editMonthlyForm.category}
                                                onChange={(e) => setEditMonthlyForm(prev => ({ ...prev, category: e.target.value }))}
                                                className="px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-primary"
                                            >
                                                <option value="spiritual">Spiritual</option>
                                                <option value="personal">Personal</option>
                                                <option value="outreach">Outreach</option>
                                                <option value="health">Health</option>
                                                <option value="work">Work</option>
                                            </select>
                                            <button
                                                onClick={() => {
                                                    updateGoal('monthly', goal.id, editMonthlyForm.text, editMonthlyForm.category);
                                                    setEditingMonthlyGoal(null);
                                                    setEditMonthlyForm({ text: '', category: 'spiritual' });
                                                }}
                                                className="px-2 py-1 text-xs bg-green-500 text-white rounded hover:bg-green-600"
                                            >
                                                Save
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setEditingMonthlyGoal(null);
                                                    setEditMonthlyForm({ text: '', category: 'spiritual' });
                                                }}
                                                className="px-2 py-1 text-xs bg-gray-500 text-white rounded hover:bg-gray-600"
                                            >
                                                Cancel
                                            </button>
                                        </div>
                                    ) : (
                                        // Display Mode
                                        <>
                                            <span className={`flex-1 ${goal.completed ? 'line-through text-gray-500' : ''}`}>
                                                {goal.text}
                                            </span>
                                            <span className={`px-2 py-1 text-xs rounded-full ${
                                                goal.category === 'spiritual' ? 'bg-blue-100 text-blue-800' :
                                                goal.category === 'personal' ? 'bg-green-100 text-green-800' :
                                                'bg-purple-100 text-purple-800'
                                            }`}>
                                                {goal.category}
                                            </span>
                                        </>
                                    )}
                                    <div className="flex space-x-1 opacity-0 group-hover:opacity-100 transition-opacity">
                                        <button
                                            onClick={() => {
                                                setEditingMonthlyGoal(goal.id);
                                                setEditMonthlyForm({ text: goal.text, category: goal.category || 'spiritual' });
                                            }}
                                            className="text-blue-500 hover:text-blue-700 p-1 rounded-full hover:bg-blue-50"
                                            title="Edit goal"
                                            >
                                            ✏️
                                        </button>
                                        <button
                                            onClick={() => removeGoal('monthly', goal.id)}
                                            className="text-red-500 hover:text-red-700 p-1 rounded-full hover:bg-red-50"
                                            title="Remove goal"
                                        >
                                            <TrashIcon />
                                        </button>
                                    </div>
                                </div>
                            ))}
                        </div>

                        {/* Add Goal Form */}
                        {showAddGoal === 'monthly' && (
                            <div className="mt-4 p-4 bg-gray-50 rounded-lg">
                                <div className="flex space-x-2">
                                    <input
                                        type="text"
                                        value={newGoalText}
                                        onChange={(e) => setNewGoalText(e.target.value)}
                                        placeholder="Enter your monthly goal..."
                                        className="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary"
                                    />
                                    <select
                                        value={newGoalCategory}
                                        onChange={(e) => setNewGoalCategory(e.target.value)}
                                        className="px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary"
                                    >
                                        <option value="spiritual">Spiritual</option>
                                        <option value="personal">Personal</option>
                                        <option value="outreach">Outreach</option>
                                    </select>
                                    <button
                                        onClick={() => handleAddGoal('monthly')}
                                        className="bg-primary hover:bg-green-700 text-white px-4 py-2 rounded-md transition-colors"
                                    >
                                        Add
                                    </button>
                                    <button
                                        onClick={() => setShowAddGoal(false)}
                                        className="px-4 py-2 text-gray-600 border border-gray-300 rounded-md hover:bg-gray-50 transition-colors"
                                    >
                                        Cancel
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>

                    {/* Action Buttons */}
                    <div className="text-center">
                        <button
                            type="button"
                            onClick={(e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                console.log('🚀 Start Today\'s Entry button clicked');
                                console.log('🎯 setCurrentView function:', typeof setCurrentView);
                                console.log('🎯 setCurrentView value:', setCurrentView);
                                try {
                                    setCurrentView('daily');
                                    console.log('✅ View changed to daily');
                                } catch (error) {
                                    console.error('❌ Error changing view:', error);
                                }
                            }}
                            className="bg-primary hover:bg-green-700 text-white font-bold py-3 px-8 rounded-full shadow-lg hover:shadow-xl transition-all duration-300"
                        >
                            Start Today's Entry
                        </button>
                    </div>
                </div>
            );
        };

        const DailyDavidApp = () => {
            const [currentDate, setCurrentDate] = useState(new Date());
            const [dayData, setDayData] = useState({});
            const [isConnected, setIsConnected] = useState(false);
            const [isLoading, setIsLoading] = useState(true);
            const [lastSaved, setLastSaved] = useState(null);
            const [currentView, setCurrentView] = useState(() => {
                // Load saved view from localStorage, default to 'landing'
                const savedView = localStorage.getItem('dailyDavid_currentView');
                return savedView || 'landing';
            }); // 'landing' or 'daily'
            
            // Wrapper for setCurrentView that saves to localStorage
            const setCurrentViewWithPersistence = (view) => {
                setCurrentView(view);
                localStorage.setItem('dailyDavid_currentView', view);
            };
            
            // Goals are now stored in userSpecificData and loaded per user
            const saveTimeoutRef = useRef(null);
            
            // Authentication state
            const [user, setUser] = useState(null);
            const [isAdmin, setIsAdmin] = useState(false);
            const [authLoading, setAuthLoading] = useState(true);
            
            // Mode preference state (persists across refreshes)
            const [userModePreference, setUserModePreference] = useState('admin'); // 'admin' or 'user'
            
            // User-specific data state (isolated per user)
            const [userSpecificData, setUserSpecificData] = useState({
                dayData: {},
                weeklyGoals: [],
                monthlyGoals: []
            });

            // Global credential prompt prevention - DISABLED to restore working sign-in form

            // Force data refresh from Neon for cross-device consistency
            const forceRefreshFromNeon = React.useCallback(async () => {
                if (!currentUserId) return;
                
                try {
                    console.log('🔄 [Cross-Device Sync] Forcing data refresh from Neon...');
                    const dbManager = new NeonDatabaseManager();
                    
                    // Get all days for the current week
                    const today = new Date();
                    const startOfWeek = new Date(today);
                    startOfWeek.setDate(today.getDate() - today.getDay());
                    const endOfWeek = new Date(startOfWeek);
                    endOfWeek.setDate(startOfWeek.getDate() + 6);
                    
                    const refreshedData = {};
                    
                    for (let d = new Date(startOfWeek); d <= endOfWeek; d.setDate(d.getDate() + 1)) {
                        const dateKey = formatDateKey(d);
                        const neonData = await dbManager.loadDayData(dateKey, currentUserId);
                        
                        if (neonData && Object.keys(neonData).length > 0) {
                            refreshedData[dateKey] = neonData;
                            console.log(`✅ [Cross-Device Sync] Refreshed data for ${dateKey}:`, neonData);
                        }
                    }
                    
                    // Update userSpecificData with fresh Neon data
                    setUserSpecificData(prev => ({
                        ...prev,
                        dayData: { ...prev.dayData, ...refreshedData }
                    }));
                    
                    console.log('✅ [Cross-Device Sync] Data refresh complete. Total days refreshed:', Object.keys(refreshedData).length);
                } catch (error) {
                    console.error('❌ [Cross-Device Sync] Failed to refresh data from Neon:', error);
                }
            }, [currentUserId]);

            // Simple setUserSpecificData - no more debugging mess



            const formatDateKey = (date) => {
                // Use local time instead of UTC to prevent timezone date shifts
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };

            // Use the working useDayData hook pattern from marriage meeting tool
            const currentDateKey = formatDateKey(currentDate);
            const currentUserId = user ? getCurrentUserId() : null;
            
            // Debug date handling and user data
            console.log('📅 [Date Debug] Current date object:', currentDate);
            console.log('📅 [Date Debug] Current date key:', currentDateKey);
            console.log('📅 [Date Debug] Local timezone offset:', currentDate.getTimezoneOffset());
            console.log('📅 [Date Debug] Device timezone:', Intl.DateTimeFormat().resolvedOptions().timeZone);
            console.log('👤 [User Debug] Current user:', user);
            console.log('👤 [User Debug] Current user ID:', currentUserId);
            console.log('👤 [User Debug] Window current user:', window.currentAuthenticatedUser);
            
            const { dayData: currentDayData, setDayData: setCurrentDayData, isLoading: dayDataLoading, error: dayDataError, manualSave } = useDayData(currentDateKey, currentUserId);

            // Test Neon connection and initialize database tables only once when app starts
            const initializeNeonAndDatabase = React.useCallback(async () => {
                try {
                    console.log('🚀 Testing Neon connection and initializing database...');
                    
                    const dbManager = new NeonDatabaseManager();
                    const connectionOk = await dbManager.testConnection();
                    
                    if (connectionOk) {
                        console.log('✅ Ready to use Neon database');
                        
                        // Initialize users table
                        await dbManager.createUsersTable();
                        
                        // Initialize daily david entries table
                        await dbManager.createDailyDavidEntriesTable();
                        
                        // Add default admin user to database if not exists
                        const currentAdminEmail = 'admin@dailydavid.com';
                        const existingAdmin = await dbManager.getUserByEmail(currentAdminEmail);
                        
                        if (!existingAdmin) {
                            console.log('➕ Adding default admin user to database...');
                            await dbManager.createUser(currentAdminEmail, 'Admin User', 'admin123', true);
                            console.log('✅ Default admin user added to database');
                            console.log('📧 Email: admin@dailydavid.com');
                            console.log('🔑 Password: admin123');
                        } else {
                            console.log('✅ Default admin user already exists in database');
                        }
                        
                        // No test users needed - users will be created through admin panel
                        
                        console.log('✅ Database initialization complete');
                    } else {
                        console.error('❌ Neon connection failed');
                    }
                } catch (error) {
                    console.error('❌ Neon initialization error:', error);
                }
            }, []);
            
            // Initialize Neon only once when component mounts
            React.useEffect(() => {
                const timer = setTimeout(() => {
                    initializeNeonAndDatabase();
                }, 1000);
                
                return () => clearTimeout(timer);
            }, [initializeNeonAndDatabase]);

            // Force data refresh when user changes or app loads for cross-device consistency
            React.useEffect(() => {
                if (currentUserId && user) {
                    console.log('🔄 [Cross-Device Sync] User authenticated, forcing data refresh...');
                    // Small delay to ensure Neon is initialized
                    const timer = setTimeout(() => {
                        forceRefreshFromNeon();
                    }, 2000);
                    
                    return () => clearTimeout(timer);
                }
            }, [currentUserId, user, forceRefreshFromNeon]);



            const formatDateDisplay = (date) => {
                return date.toLocaleDateString('en-US', { 
                    weekday: 'long', 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                });
            };

            // Helper functions for goal carryover
            const isSameWeek = (date1, date2) => {
                const week1 = getWeekNumber(date1);
                const week2 = getWeekNumber(date2);
                return week1.year === week2.year && week1.week === week2.week;
            };

            const isSameMonth = (date1, date2) => {
                return date1.getFullYear() === date2.getFullYear() && 
                       date1.getMonth() === date2.getMonth();
            };

            const getWeekNumber = (date) => {
                const d = new Date(date);
                d.setHours(0, 0, 0, 0);
                d.setDate(d.getDate() + 4 - (d.getDay() || 7));
                const yearStart = new Date(d.getFullYear(), 0, 1);
                const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
                return { year: d.getFullYear(), week: weekNo };
            };

            const getMostRecentGoals = (goalType, excludeDateKey = null) => {
                // Find the most recent day with goals of this type, excluding the specified date
                const sortedDates = Object.keys(userSpecificData.dayData)
                    .sort((a, b) => new Date(b) - new Date(a));
                
                for (const dateKey of sortedDates) {
                    // Skip the excluded date
                    if (excludeDateKey && dateKey === excludeDateKey) {
                        continue;
                    }
                    
                    const dayData = userSpecificData.dayData[dateKey];
                    if (dayData?.goals?.[goalType]?.length > 0) {
                        return dayData.goals[goalType];
                    }
                }
                return [];
            };

            // Load day data from database and localStorage
            const loadDayData = async (dateKey) => {
                if (!user) return null;
                
                // First try to load from localStorage
                const localStorageKey = `dailyDavid_dayData_${user.id}`;
                try {
                    const localStorageData = localStorage.getItem(localStorageKey);
                    if (localStorageData) {
                        const parsedData = JSON.parse(localStorageData);
                        if (parsedData[dateKey]) {
                            console.log('Loaded day data from localStorage for date:', dateKey);
                            return parsedData[dateKey];
                        }
                    }
                } catch (error) {
                    console.error('Error loading from localStorage:', error);
                }
                
                // If no localStorage data, try database
                console.log('No localStorage data, trying database for date:', dateKey);
                try {
                    const dbManager = new NeonDatabaseManager();
        const data = await dbManager.loadDayData(dateKey, user.id);

                    if (data) {
                        console.log('Loaded day data from database for date:', dateKey);
                        // Also save to localStorage for future use
                        try {
                            const existingData = localStorage.getItem(localStorageKey);
                            const parsedData = existingData ? JSON.parse(existingData) : {};
                            parsedData[dateKey] = data;
                            localStorage.setItem(localStorageKey, JSON.stringify(parsedData));
                            console.log('Day data also saved to localStorage');
                        } catch (localError) {
                            console.error('Error saving to localStorage:', localError);
                        }
                        return data;
                    }

                    return null;
                } catch (error) {
                    console.log('Load error from database:', error);
                    return null;
                }
            };

            // Save day data to database and localStorage - AGGRESSIVE localStorage backup
            const saveDayData = async (dateKey, data) => {
                if (!user) return false;
                
                // DEBUG: Log what data is being saved
                console.log('💾 DEBUG: saveDayData called with:');
                console.log('💾 DEBUG: dateKey:', dateKey);
                console.log('💾 DEBUG: data:', data);
                console.log('💾 DEBUG: data.gratitude:', data?.gratitude);
                console.log('💾 DEBUG: data.soap:', data?.soap);
                console.log('💾 DEBUG: data.gratitude.length:', data?.gratitude?.length);
                console.log('💾 DEBUG: data.gratitude[0]:', data?.gratitude?.[0]);
                console.log('💾 DEBUG: data.gratitude[1]:', data?.gratitude?.[1]);
                console.log('💾 DEBUG: data.soap.scripture:', data?.soap?.scripture);
                
                // AGGRESSIVE: Save to localStorage MULTIPLE times with multiple keys
                const localStorageKey = `dailyDavid_dayData_${user.id}`;
                const backupKey = `dailyDavid_dayData_backup_${user.id}`;
                const emergencyKey = `dailyDavid_dayData_emergency_${user.id}`;
                
                try {
                    const existingData = localStorage.getItem(localStorageKey);
                    const parsedData = existingData ? JSON.parse(existingData) : {};
                    parsedData[dateKey] = data;
                    
                    // DEBUG: Log what's being saved to localStorage
                    console.log('💾 DEBUG: Saving to localStorage:');
                    console.log('💾 DEBUG: parsedData[dateKey]:', parsedData[dateKey]);
                    console.log('💾 DEBUG: parsedData[dateKey].gratitude:', parsedData[dateKey]?.gratitude);
                    console.log('💾 DEBUG: parsedData[dateKey].soap:', parsedData[dateKey]?.soap);
                    
                    // Save to primary key
                    localStorage.setItem(localStorageKey, JSON.stringify(parsedData));
                    console.log('💾 AGGRESSIVE: Day data saved to localStorage (primary):', dateKey);
                    
                    // Save to backup key
                    localStorage.setItem(backupKey, JSON.stringify(parsedData));
                    console.log('💾 AGGRESSIVE: Day data saved to backup localStorage:', dateKey);
                    
                    // Save to emergency key
                    localStorage.setItem(emergencyKey, JSON.stringify(parsedData));
                    console.log('💾 AGGRESSIVE: Day data saved to emergency localStorage:', dateKey);
                    
                    // Save again after a tiny delay
                    setTimeout(() => {
                        try {
                            localStorage.setItem(localStorageKey, JSON.stringify(parsedData));
                            localStorage.setItem(backupKey, JSON.stringify(parsedData));
                            console.log('💾 AGGRESSIVE: Day data saved again (delayed):', dateKey);
                        } catch (error) {
                            console.error('❌ Error in delayed save:', error);
                        }
                    }, 100);
                    
                } catch (error) {
                    console.error('Error saving to localStorage:', error);
                }
                
                try {
                    const dbManager = new NeonDatabaseManager();
        const success = await dbManager.saveDayData(dateKey, user.id, data);

                    if (!success) {
                        console.log('Save error: Database save failed');
                        console.log('Day data saved to localStorage as backup');
                        return false;
                    }

                    setLastSaved(new Date());
                    console.log('Day data saved successfully to database');
                    return true;
                } catch (error) {
                    console.log('Save error:', error);
                    console.log('Day data saved to localStorage as backup');
                    return false;
                }
            };

            // Debounced save - waits 1 second after typing stops
            const debouncedSave = useCallback((dateKey, data) => {
                console.log('⏰ DEBUG: debouncedSave called with:');
                console.log('⏰ DEBUG: dateKey:', dateKey);
                console.log('⏰ DEBUG: data:', data);
                console.log('⏰ DEBUG: data.gratitude:', data?.gratitude);
                console.log('⏰ DEBUG: data.soap:', data?.soap);
                
                if (saveTimeoutRef.current) {
                    clearTimeout(saveTimeoutRef.current);
                }
                saveTimeoutRef.current = setTimeout(() => {
                    console.log('⏰ DEBUG: debouncedSave timeout fired, calling saveDayData');
                    saveDayData(dateKey, data);
                }, 1000);
            }, []);

            // Initialize database connection
            const initializeDatabase = async () => {
                setIsConnected(true);
            };

            // Function to clear user data when switching between different users
            const clearUserData = () => {
                console.log('🚨 CLEARING USER DATA - switching to different user');
                console.trace('clearUserData called from:'); // This will show the call stack
                setUserSpecificData({
                    dayData: {},
                    weeklyGoals: [],
                    monthlyGoals: []
                });
                                        setCurrentViewWithPersistence('landing');
                setCurrentDate(new Date());
            };

            // Function to save goals to database and localStorage
            const saveGoals = async (weeklyGoals, monthlyGoals) => {
                if (!user) {
                    console.log('No user, cannot save goals');
                    return false;
                }
                
                // Always save to localStorage as backup
                const localStorageKey = `dailyDavid_goals_${user.id}`;
                const goalsData = {
                    weeklyGoals: weeklyGoals,
                    monthlyGoals: monthlyGoals,
                    lastUpdated: new Date().toISOString()
                };
                
                try {
                    localStorage.setItem(localStorageKey, JSON.stringify(goalsData));
                    console.log('Goals saved to localStorage:', goalsData);
                } catch (error) {
                    console.error('Error saving to localStorage:', error);
                }
                
                try {
                    console.log('Saving goals to database:', { weeklyGoals, monthlyGoals, userId: user.id });
                    
                    const dbManager = new NeonDatabaseManager();
        const { data, error } = await dbManager.saveGoals(user.id, goalsData);

                    if (error) {
                        console.error('Save goals error:', error);
                        console.log('Goals saved to localStorage as backup');
                        return false;
                    }

                    console.log('Goals saved successfully to database:', data);
                    return true;
                } catch (error) {
                    console.error('Save goals exception:', error);
                    console.log('Goals saved to localStorage as backup');
                    return false;
                }
            };

                        // Function to load user-specific data - BULLETPROOF localStorage approach
            const loadUserSpecificData = async (userId) => {
                try {
                    console.log('🔄 BULLETPROOF: Loading user-specific data for:', userId);
                    
                    // DIRECT localStorage access - no complex logic
                    const goalsKey = `dailyDavid_goals_${userId}`;
                    const dayDataKey = `dailyDavid_dayData_${userId}`;
                    
                    console.log('🔑 Goals key:', goalsKey);
                    console.log('🔑 Day data key:', dayDataKey);
                    
                    // Try to load goals from database first, then localStorage as backup
                    let weeklyGoals = [];
                    let monthlyGoals = [];
                    let dayData = {};
                    
                    try {
                        // First try to load from database
                        console.log('🔄 Trying to load goals from database...');
                        const dbManager = new NeonDatabaseManager();
        const dbGoalsData = await dbManager.loadGoals(userId);
                        
                        if (dbGoalsData) {
                            weeklyGoals = dbGoalsData.weeklyGoals || [];
                            monthlyGoals = dbGoalsData.monthlyGoals || [];
                            console.log('✅ Goals loaded from database:', { weeklyGoals, monthlyGoals });
                            
                            // Also save to localStorage as backup
                            try {
                                localStorage.setItem(goalsKey, JSON.stringify(dbGoalsData));
                                console.log('✅ Goals also saved to localStorage as backup');
                            } catch (localError) {
                                console.error('❌ Error saving goals to localStorage:', localError);
                            }
                        } else {
                            // Fall back to localStorage
                            console.log('⚠️ No goals in database, trying localStorage...');
                            const goalsData = localStorage.getItem(goalsKey);
                            if (goalsData) {
                                const parsed = JSON.parse(goalsData);
                                weeklyGoals = parsed.weeklyGoals || [];
                                monthlyGoals = parsed.monthlyGoals || [];
                                console.log('✅ Goals loaded from localStorage:', { weeklyGoals, monthlyGoals });
                            } else {
                                console.log('⚠️ No goals found anywhere, using defaults');
                                weeklyGoals = [
                                    { id: 1, text: 'Complete 5 SOAP studies this week', completed: false, category: 'spiritual' },
                                    { id: 2, text: 'Practice gratitude daily', completed: false, category: 'personal' },
                                    { id: 3, text: 'Read 3 chapters of scripture', completed: false, category: 'spiritual' }
                                ];
                                monthlyGoals = [
                                    { id: 1, text: 'Establish daily prayer routine', completed: false, category: 'spiritual' },
                                    { id: 2, text: 'Complete 20 SOAP studies', completed: false, category: 'spiritual' },
                                    { id: 3, text: 'Share faith with 2 people', completed: false, category: 'outreach' }
                                ];
                            }
                        }
                    } catch (error) {
                        console.error('❌ Error loading goals from database/localStorage:', error);
                        // Use defaults on error
                        weeklyGoals = [
                            { id: 1, text: 'Complete 5 SOAP studies this week', completed: false, category: 'spiritual' },
                            { id: 2, text: 'Practice gratitude daily', completed: false, category: 'personal' },
                            { id: 3, text: 'Read 3 chapters of scripture', completed: false, category: 'spiritual' }
                        ];
                        monthlyGoals = [
                            { id: 1, text: 'Establish daily prayer routine', completed: false, category: 'spiritual' },
                            { id: 2, text: 'Complete 20 SOAP studies', completed: false, category: 'spiritual' },
                            { id: 3, text: 'Share faith with 2 people', completed: false, category: 'outreach' }
                        ];
                    }
                    
                    // Try to load day data from database first, then localStorage as backup
                    try {
                        console.log('🔄 Trying to load day data from database...');
                        // For now, we'll load from localStorage but in the future we can implement
                        // batch loading from database for multiple dates
                        const dayDataRaw = localStorage.getItem(dayDataKey);
                        if (dayDataRaw) {
                            dayData = JSON.parse(dayDataRaw);
                            console.log('✅ Day data loaded from localStorage:', Object.keys(dayData).length, 'dates');
                            console.log('📅 Date keys:', Object.keys(dayData));
                            
                            // Extract goals from the most recent day data
                            const dateKeys = Object.keys(dayData).sort((a, b) => new Date(b) - new Date(a));
                            if (dateKeys.length > 0) {
                                const mostRecentDate = dateKeys[0];
                                const mostRecentData = dayData[mostRecentDate];
                                
                                if (mostRecentData?.goals) {
                                    weeklyGoals = mostRecentData.goals.weekly || [];
                                    monthlyGoals = mostRecentData.goals.monthly || [];
                                    console.log('✅ Goals extracted from most recent day data:', { 
                                        date: mostRecentDate, 
                                        weeklyGoals: weeklyGoals.length, 
                                        monthlyGoals: monthlyGoals.length 
                                    });
                                }
                            }
                        } else {
                            console.log('⚠️ No day data in localStorage, starting fresh');
                            dayData = {};
                        }
                    } catch (error) {
                        console.error('❌ Error loading day data from localStorage:', error);
                        dayData = {};
                    }
                    
                    // FORCE update the state with what we loaded
                    console.log('🔄 FORCING state update with loaded data');
                    console.log('📊 Day data to set:', dayData);
                    console.log('📊 Weekly goals to set:', weeklyGoals);
                    console.log('📊 Monthly goals to set:', monthlyGoals);
                    
                    setUserSpecificData({
                        dayData: dayData,
                        weeklyGoals: weeklyGoals,
                        monthlyGoals: monthlyGoals
                    });
                    
                    console.log('✅ BULLETPROOF: User-specific data loaded and state updated');
                    
                } catch (error) {
                    console.error('❌ CRITICAL ERROR in loadUserSpecificData:', error);
                    // Emergency fallback
                    setUserSpecificData({
                        dayData: {},
                        weeklyGoals: [
                            { id: 1, text: 'Complete 5 SOAP studies this week', completed: false, category: 'spiritual' },
                            { id: 2, text: 'Practice gratitude daily', completed: false, category: 'personal' },
                            { id: 3, text: 'Read 3 chapters of scripture', completed: false, category: 'spiritual' }
                        ],
                        monthlyGoals: [
                            { id: 1, text: 'Establish daily prayer routine', completed: false, category: 'spiritual' },
                            { id: 2, text: 'Complete 20 SOAP studies', completed: false, category: 'spiritual' },
                            { id: 3, text: 'Share faith with 2 people', completed: false, category: 'outreach' }
                        ]
                    });
                }
            };

            // Authentication handlers - Simplified approach
            const handleSignIn = async (userData) => {
                console.log('🔐 User signing in:', userData.email);
                
                // ALWAYS load user data from localStorage first, regardless of same user or not
                console.log('🔄 Loading user-specific data from localStorage...');
                await loadUserSpecificData(userData.id);
                
                // Set user state after loading data
                setUser(userData);
                setIsAdmin(false); // Regular users are never admin
                
                console.log('✅ User sign-in complete, data loaded from localStorage');
            };

            const handleAdminSignIn = async (userData) => {
                console.log('👑 Admin signing in:', userData.email);
                
                // Admin users only get admin functionality
                setUser(userData);
                setIsAdmin(true);
                setUserModePreference('admin');
                
                // Don't load user-specific data for admin users
                // They only manage other users
            };

            // Remove the mode switching function - no longer needed

            const handleSignOut = async () => {
                try {
                    console.log('User signing out');
                    
                    // Clear authenticated user (copied from working marriage meeting tool)
                    setUser(null);
                    setIsAdmin(false);
                    window.currentAuthenticatedUser = null;
                    
                    // Clear stored authentication
                    localStorage.removeItem('dailyDavidAuth');
                    console.log('✅ User signed out and authentication cleared');
                } catch (error) {
                    console.error('Sign out error:', error);
                }
            };

            const handleAddUser = async (email, password, displayName) => {
                try {
                    console.log('Creating new user:', { email, password, displayName });
                    
                    // Simple user creation like marriage meeting tool
                    const newUser = {
                        id: email,
                        email: email,
                        display_name: displayName,
                        is_admin: false,
                        created_at: new Date().toISOString()
                    };
                    
                    setUsers([...users, newUser]);
                    alert(`User ${email} created successfully!`);
                    
                    // Clear form
                    setNewUserEmail('');
                    setNewUserPassword('');
                    setNewUserDisplayName('');
                    
                    console.log('✅ User created successfully:', newUser);
                } catch (error) {
                    console.error('❌ Create user error:', error);
                    alert(`Error creating user: ${error.message}`);
                }
            };

            const handleRemoveUser = async (userId) => {
                if (!confirm('Are you sure you want to remove this user? This action cannot be undone.')) {
                    return;
                }
                
                try {
                    console.log('Attempting to remove user:', userId);
                    
                    // Simple user deletion like marriage meeting tool
                    const updatedUsers = users.filter(u => u.id !== userId);
                    setUsers(updatedUsers);
                    console.log('Updated local users list:', updatedUsers);
                    
                    alert('User removed successfully!');
                } catch (error) {
                    console.error('❌ Remove user error:', error);
                    alert(`Error removing user: ${error.message}`);
                }
            };

            const handleSwitchToUserMode = async () => {
                await switchAdminToUserMode();
            };

            // Goal management functions
            const toggleGoal = async (goalType, goalId) => {
                const dateKey = formatDateKey(currentDate);
                
                // Use the hook's state instead of userSpecificData
                if (!currentDayData) return;
                
                // Update the hook's state directly (this will auto-save to Neon)
                setCurrentDayData(prevData => {
                    if (!prevData) return prevData;
                    
                    const updatedData = { ...prevData };
                    if (!updatedData.goals) updatedData.goals = {};
                    if (!updatedData.goals[goalType]) updatedData.goals[goalType] = [];
                    
                    const goalIndex = updatedData.goals[goalType].findIndex(g => g.id === goalId);
                    
                    if (goalIndex !== -1) {
                        const newCompletedStatus = !updatedData.goals[goalType][goalIndex].completed;
                        updatedData.goals[goalType][goalIndex].completed = newCompletedStatus;
                        
                        console.log('🎯 [toggleGoal] Toggled goal:', { goalType, goalId, newCompletedStatus, updatedData });
                        
                        // For weekly/monthly goals, sync completion status across all days in same week/month
                        if (goalType === 'weekly' || goalType === 'monthly') {
                            // Note: syncGoalCompletionAcrossDays still uses old state, but this is the main goal toggle
                            // The sync function will need to be updated separately if needed
                        }
                        
                        return updatedData;
                    }
                    
                    return prevData;
                });
                
                // Also update localStorage as backup
                const dayDataKey = `dailyDavid_dayData_${user.id}`;
                const allDayData = { ...userSpecificData.dayData, [dateKey]: currentDayData };
                localStorage.setItem(dayDataKey, JSON.stringify(allDayData));
            };

            const addGoal = async (goalType, text, category) => {
                const dateKey = formatDateKey(currentDate);
                
                // Use the hook's state instead of userSpecificData
                if (!currentDayData) return;
                
                // Create goal with provided text and category
                const newGoal = {
                    id: Date.now(),
                    text: text,
                    completed: false,
                    category: category
                };
                
                // Update the hook's state directly (this will auto-save to Neon)
                setCurrentDayData(prevData => {
                    if (!prevData) return prevData;
                    
                    const updatedData = { ...prevData };
                    if (!updatedData.goals) updatedData.goals = {};
                    if (!updatedData.goals[goalType]) updatedData.goals[goalType] = [];
                    
                    updatedData.goals[goalType].push(newGoal);
                    
                    console.log('🎯 [addGoal] Added goal:', { goalType, newGoal, updatedData });
                    return updatedData;
                });
                
                // Also update localStorage as backup
                const dayDataKey = `dailyDavid_dayData_${user.id}`;
                const allDayData = { ...userSpecificData.dayData, [dateKey]: currentDayData };
                localStorage.setItem(dayDataKey, JSON.stringify(allDayData));
            };

            const removeGoal = async (goalType, goalId) => {
                const dateKey = formatDateKey(currentDate);
                
                // Use the hook's state instead of userSpecificData
                if (!currentDayData) return;
                
                // Update the hook's state directly (this will auto-save to Neon)
                setCurrentDayData(prevData => {
                    if (!prevData) return prevData;
                    
                    const updatedData = { ...prevData };
                    if (!updatedData.goals) updatedData.goals = {};
                    if (!updatedData.goals[goalType]) updatedData.goals[goalType] = [];
                    
                    updatedData.goals[goalType] = updatedData.goals[goalType].filter(g => g.id !== goalId);
                    
                    console.log('🎯 [removeGoal] Removed goal:', { goalType, goalId, updatedData });
                    return updatedData;
                });
                
                // Also update localStorage as backup
                const dayDataKey = `dailyDavid_dayData_${user.id}`;
                const allDayData = { ...userSpecificData.dayData, [dateKey]: currentDayData };
                localStorage.setItem(dayDataKey, JSON.stringify(allDayData));
            };

            const updateGoal = async (goalType, goalId, newText, newCategory) => {
                const dateKey = formatDateKey(currentDate);
                
                // Use the hook's state instead of userSpecificData
                if (!currentDayData) return;
                
                // Update the hook's state directly (this will auto-save to Neon)
                setCurrentDayData(prevData => {
                    if (!prevData) return prevData;
                    
                    const updatedData = { ...prevData };
                    if (!updatedData.goals) updatedData.goals = {};
                    if (!updatedData.goals[goalType]) updatedData.goals[goalType] = [];
                    
                    const goalIndex = updatedData.goals[goalType].findIndex(g => g.id === goalId);
                    
                    if (goalIndex !== -1) {
                        updatedData.goals[goalType][goalIndex].text = newText;
                        updatedData.goals[goalType][goalIndex].category = newCategory;
                        
                        console.log('🎯 [updateGoal] Updated goal:', { goalType, goalId, newText, newCategory, updatedData });
                        return updatedData;
                    }
                    
                    return prevData;
                });
                
                // Also update localStorage as backup
                const dayDataKey = `dailyDavid_dayData_${user.id}`;
                const allDayData = { ...userSpecificData.dayData, [dateKey]: currentDayData };
                localStorage.setItem(dayDataKey, JSON.stringify(allDayData));
            };

            // Function to sync goal completion across all days in same week/month
            const syncGoalCompletionAcrossDays = async (goalType, goalId, completedStatus) => {
                const allDayData = { ...userSpecificData.dayData };
                let updated = false;
                
                // Get all dates that have this goal type
                const datesWithGoals = Object.keys(allDayData).filter(dateKey => {
                    const dayData = allDayData[dateKey];
                    return dayData?.goals?.[goalType]?.some(g => g.id === goalId);
                });
                
                // Update completion status for all days that have this goal
                for (const dateKey of datesWithGoals) {
                    const dayData = allDayData[dateKey];
                    const goalIndex = dayData.goals[goalType].findIndex(g => g.id === goalId);
                    
                    if (goalIndex !== -1) {
                        dayData.goals[goalType][goalIndex].completed = completedStatus;
                        updated = true;
                    }
                }
                
                if (updated) {
                    // Save all updated day data to localStorage
                    const dayDataKey = `dailyDavid_dayData_${user.id}`;
                    localStorage.setItem(dayDataKey, JSON.stringify(allDayData));
                    
                    // Update state
                    setUserSpecificData(prev => ({
                        ...prev,
                        dayData: allDayData
                    }));
                }
            };

            // Function to ensure goals are carried over when navigating between dates
            const ensureGoalsCarryOver = (dateKey) => {
                const currentDayData = userSpecificData.dayData[dateKey];
                if (!currentDayData) return;
                
                console.log('🔄 DEBUG: ensureGoalsCarryOver called for date:', dateKey);
                console.log('🔄 DEBUG: Current day data goals:', currentDayData.goals);
                console.log('🔄 DEBUG: Current day weekly goals:', currentDayData.goals?.weekly);
                console.log('🔄 DEBUG: Current day monthly goals:', currentDayData.goals?.monthly);
                console.log('🔄 DEBUG: Current day weekly goals length:', currentDayData.goals?.weekly?.length);
                console.log('🔄 DEBUG: Current day monthly goals length:', currentDayData.goals?.monthly?.length);
                
                // Check if we need to carry over weekly/monthly goals
                const currentDate = new Date(dateKey);
                let needsUpdate = false;
                const updatedDayData = { ...currentDayData };
                
                // Find goals from other days in the same week/month
                const allDates = Object.keys(userSpecificData.dayData);
                const sortedDates = allDates.sort((a, b) => new Date(b) - new Date(a));
                console.log('🔄 DEBUG: All available dates:', allDates);
                console.log('🔄 DEBUG: Sorted dates (most recent first):', sortedDates);
                
                // Check weekly goals - compare with most recent goals to see if they need updating
                const mostRecentWeeklyGoals = getMostRecentGoals('weekly', dateKey);
                if (mostRecentWeeklyGoals.length > 0) {
                    const currentWeeklyGoals = updatedDayData.goals.weekly || [];
                    const weeklyGoalsNeedUpdate = currentWeeklyGoals.length !== mostRecentWeeklyGoals.length ||
                        !currentWeeklyGoals.every((goal, index) => goal.id === mostRecentWeeklyGoals[index]?.id);
                    
                    if (weeklyGoalsNeedUpdate && isSameWeek(currentDate, new Date(sortedDates[0]))) {
                        console.log('🔄 DEBUG: Weekly goals need updating, carrying over from most recent:', mostRecentWeeklyGoals);
                        updatedDayData.goals.weekly = mostRecentWeeklyGoals.map(goal => ({
                            ...goal,
                            completed: goal.completed // Keep completion status
                        }));
                        needsUpdate = true;
                    }
                }
                
                // Check monthly goals - use same logic as weekly goals
                const mostRecentMonthlyGoals = getMostRecentGoals('monthly', dateKey);
                if (mostRecentMonthlyGoals.length > 0) {
                    const currentMonthlyGoals = updatedDayData.goals.monthly || [];
                    const monthlyGoalsNeedUpdate = currentMonthlyGoals.length !== mostRecentMonthlyGoals.length ||
                        !currentMonthlyGoals.every((goal, index) => goal.id === mostRecentMonthlyGoals[index]?.id);
                    
                    console.log('🔄 DEBUG: Monthly goals check - current:', currentMonthlyGoals.length, 'recent:', mostRecentMonthlyGoals.length, 'needUpdate:', monthlyGoalsNeedUpdate);
                    
                    if (monthlyGoalsNeedUpdate && isSameMonth(currentDate, new Date(sortedDates[0]))) {
                        console.log('🔄 DEBUG: Updating monthly goals from', currentMonthlyGoals.length, 'to', mostRecentMonthlyGoals.length);
                        updatedDayData.goals.monthly = mostRecentMonthlyGoals.map(goal => ({
                            ...goal,
                            completed: goal.completed // Keep completion status
                        }));
                        needsUpdate = true;
                    }
                }
                
                if (needsUpdate) {
                    console.log('🔄 DEBUG: Updating goals for date:', dateKey);
                    console.log('🔄 DEBUG: Updated goals:', updatedDayData.goals);
                    
                    // Save updated data
                    const dayDataKey = `dailyDavid_dayData_${user.id}`;
                    const allDayData = { ...userSpecificData.dayData, [dateKey]: updatedDayData };
                    localStorage.setItem(dayDataKey, JSON.stringify(allDayData));
                    
                    setUserSpecificData(prev => ({
                        ...prev,
                        dayData: { ...prev.dayData, [dateKey]: updatedDayData }
                    }));
                } else {
                    console.log('🔄 DEBUG: No goals need to be carried over for date:', dateKey);
                }
            };

            // Progress calculation functions - now work with current day's goals
            const getWeeklyProgress = () => {
                const weeklyGoals = currentDayData?.goals?.weekly || [];
                const completed = weeklyGoals.filter(goal => goal.completed).length;
                return { completed, total: weeklyGoals.length, percentage: weeklyGoals.length > 0 ? Math.round((completed / weeklyGoals.length) * 100) : 0 };
            };

            const getMonthlyProgress = () => {
                const monthlyGoals = currentDayData?.goals?.monthly || [];
                const completed = monthlyGoals.filter(goal => goal.completed).length;
                return { completed, total: monthlyGoals.length, percentage: monthlyGoals.length > 0 ? Math.round((completed / monthlyGoals.length) * 100) : 0 };
            };

            const getDaysCompletedThisWeek = () => {
                // Force data refresh from Neon database for cross-device consistency
                if (!userSpecificData || !userSpecificData.dayData) {
                    console.log('⚠️ [getDaysCompletedThisWeek] userSpecificData not ready yet');
                    return 0;
                }
                
                // Log the actual data being used for debugging cross-device sync
                console.log('📱 [Cross-Device Debug] getDaysCompletedThisWeek using data:', {
                    userSpecificDataKeys: Object.keys(userSpecificData.dayData),
                    currentUserId: currentUserId,
                    deviceInfo: {
                        userAgent: navigator.userAgent,
                        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                        timestamp: new Date().toISOString()
                    }
                });
                
                const today = new Date();
                const startOfWeek = new Date(today);
                startOfWeek.setDate(today.getDate() - today.getDay());
                const endOfWeek = new Date(startOfWeek);
                endOfWeek.setDate(startOfWeek.getDate() + 6);
                
                let completedDays = 0;
                for (let d = new Date(startOfWeek); d <= endOfWeek; d.setDate(d.getDate() + 1)) {
                    const dateKey = formatDateKey(d);
                    const dayData = userSpecificData.dayData[dateKey];
                    
                    if (dayData) {
                        // Debug: Log the actual day data structure
                        console.log(`🔍 [getDaysCompletedThisWeek] Checking day ${dateKey}:`, dayData);
                        
                        // More robust checks that handle different data structures
                        const hasDailyIntention = dayData.dailyIntention && 
                            typeof dayData.dailyIntention === 'string' && 
                            dayData.dailyIntention.trim() !== '';
                        
                        const hasLeadershipRating = dayData.leadershipRating && 
                            typeof dayData.leadershipRating === 'object' && 
                            Object.values(dayData.leadershipRating).some(rating => 
                                rating !== null && rating !== undefined && rating !== 5
                            );
                        
                        const hasGrowthQuestion = dayData.growthQuestion && 
                            typeof dayData.growthQuestion === 'string' && 
                            dayData.growthQuestion.trim() !== '';
                        
                        const hasCheckIn = dayData.checkIn && (
                            (dayData.checkIn.emotions && Array.isArray(dayData.checkIn.emotions) && dayData.checkIn.emotions.length > 0) || 
                            (dayData.checkIn.feeling && typeof dayData.checkIn.feeling === 'string' && dayData.checkIn.feeling.trim() !== '')
                        );
                        
                        const hasGratitude = dayData.gratitude && 
                            Array.isArray(dayData.gratitude) && 
                            dayData.gratitude.some(item => 
                                item && typeof item === 'string' && item.trim() !== ''
                            );
                        
                        const hasSOAP = dayData.soap && (
                            (dayData.soap.scripture && typeof dayData.soap.scripture === 'string' && dayData.soap.scripture.trim() !== '') ||
                            (dayData.soap.observation && typeof dayData.soap.observation === 'string' && dayData.soap.observation.trim() !== '') ||
                            (dayData.soap.application && typeof dayData.soap.application === 'string' && dayData.soap.application.trim() !== '') ||
                            (dayData.soap.prayer && typeof dayData.soap.prayer === 'string' && dayData.soap.prayer.trim() !== '')
                        );
                        
                        const hasDailyGoals = dayData.goals && 
                            dayData.goals.daily && 
                            Array.isArray(dayData.goals.daily) && 
                            dayData.goals.daily.length > 0 &&
                            dayData.goals.daily.some(goal => 
                                goal && goal.text && typeof goal.text === 'string' && goal.text.trim() !== ''
                            );
                        
                        // Day is completed if it has at least 2 meaningful sections filled out (reduced from 3)
                        const allSections = [hasDailyIntention, hasLeadershipRating, hasGrowthQuestion, hasCheckIn, hasGratitude, hasSOAP, hasDailyGoals];
                        const meaningfulSections = allSections.filter(Boolean).length;
                        
                        console.log(`🔍 [getDaysCompletedThisWeek] Day ${dateKey} section check:`, {
                            hasDailyIntention, hasLeadershipRating, hasGrowthQuestion, hasCheckIn, hasGratitude, hasSOAP, hasDailyGoals,
                            meaningfulSections, required: 2
                        });
                        
                        if (meaningfulSections >= 2) {
                            completedDays++;
                            console.log(`✅ [getDaysCompletedThisWeek] Day ${dateKey} completed with ${meaningfulSections} sections`);
                        } else {
                            console.log(`⚠️ [getDaysCompletedThisWeek] Day ${dateKey} has data but only ${meaningfulSections} sections`);
                        }
                    }
                }
                console.log(`📊 [getDaysCompletedThisWeek] Week summary: ${completedDays}/7 days completed`);
                return completedDays;
            };

            // New dashboard enhancement functions
            const getCompletionRate = () => {
                // Ensure userSpecificData is available
                if (!userSpecificData || !userSpecificData.dayData) {
                    console.log('⚠️ [getCompletionRate] userSpecificData not ready yet');
                    return { overall: 0, sections: {} };
                }
                
                const today = new Date();
                const startOfWeek = new Date(today);
                startOfWeek.setDate(today.getDate() - today.getDay());
                const endOfWeek = new Date(startOfWeek);
                endOfWeek.setDate(startOfWeek.getDate() + 6);
                
                const sections = ['dailyIntention', 'leadershipRating', 'growthQuestion', 'checkIn', 'gratitude', 'soap', 'dailyGoals'];
                const sectionData = {};
                
                // Initialize section data
                sections.forEach(section => {
                    sectionData[section] = { completed: 0, total: 0 };
                });
                
                // Count completed sections for each day
                for (let d = new Date(startOfWeek); d <= endOfWeek; d.setDate(d.getDate() + 1)) {
                    const dateKey = formatDateKey(d);
                    const dayData = userSpecificData.dayData[dateKey];
                    
                    if (dayData) {
                        sections.forEach(section => {
                            sectionData[section].total++;
                            
                            let isCompleted = false;
                            switch (section) {
                                case 'dailyIntention':
                                    isCompleted = dayData.dailyIntention && 
                                        typeof dayData.dailyIntention === 'string' && 
                                        dayData.dailyIntention.trim() !== '';
                                    break;
                                case 'leadershipRating':
                                    isCompleted = dayData.leadershipRating && 
                                        typeof dayData.leadershipRating === 'object' && 
                                        Object.values(dayData.leadershipRating).some(rating => 
                                            rating !== null && rating !== undefined && rating !== 5
                                        );
                                    break;
                                case 'growthQuestion':
                                    isCompleted = dayData.growthQuestion && 
                                        typeof dayData.growthQuestion === 'string' && 
                                        dayData.growthQuestion.trim() !== '';
                                    break;
                                case 'checkIn':
                                    isCompleted = dayData.checkIn && (
                                        (dayData.checkIn.emotions && Array.isArray(dayData.checkIn.emotions) && dayData.checkIn.emotions.length > 0) || 
                                        (dayData.checkIn.feeling && typeof dayData.checkIn.feeling === 'string' && dayData.checkIn.feeling.trim() !== '')
                                    );
                                    break;
                                case 'gratitude':
                                    isCompleted = dayData.gratitude && 
                                        Array.isArray(dayData.gratitude) && 
                                        dayData.gratitude.some(item => 
                                            item && typeof item === 'string' && item.trim() !== ''
                                        );
                                    break;
                                case 'soap':
                                    isCompleted = dayData.soap && (
                                        (dayData.soap.scripture && typeof dayData.soap.scripture === 'string' && dayData.soap.scripture.trim() !== '') ||
                                        (dayData.soap.observation && typeof dayData.soap.observation === 'string' && dayData.soap.observation.trim() !== '') ||
                                        (dayData.soap.application && typeof dayData.soap.application === 'string' && dayData.soap.application.trim() !== '') ||
                                        (dayData.soap.prayer && typeof dayData.soap.prayer === 'string' && dayData.soap.prayer.trim() !== '')
                                    );
                                    break;
                                case 'dailyGoals':
                                    isCompleted = dayData.goals && 
                                        dayData.goals.daily && 
                                        Array.isArray(dayData.goals.daily) && 
                                        dayData.goals.daily.length > 0 &&
                                        dayData.goals.daily.some(goal => 
                                            goal && goal.text && typeof goal.text === 'string' && goal.text.trim() !== ''
                                        );
                                    break;
                            }
                            
                            if (isCompleted) {
                                sectionData[section].completed++;
                            }
                        });
                    }
                }
                
                // Calculate percentages
                const overall = sections.reduce((sum, section) => {
                    const sectionInfo = sectionData[section];
                    return sum + (sectionInfo.total > 0 ? (sectionInfo.completed / sectionInfo.total) * 100 : 0);
                }, 0) / sections.length;
                
                // Add debug logging
                console.log('📊 [getCompletionRate] Debug info:', {
                    startOfWeek: startOfWeek.toDateString(),
                    endOfWeek: endOfWeek.toDateString(),
                    sectionData,
                    overall: Math.round(overall)
                });
                
                return {
                    overall: Math.round(overall),
                    sections: Object.fromEntries(
                        sections.map(section => [
                            section,
                            Math.round((sectionData[section].completed / sectionData[section].total) * 100) || 0
                        ])
                    )
                };
            };

            const getCurrentStreak = () => {
                // Ensure userSpecificData is available
                if (!userSpecificData || !userSpecificData.dayData) {
                    console.log('⚠️ [getCurrentStreak] userSpecificData not ready yet');
                    return { current: 0, best: 0 };
                }
                
                const today = new Date();
                let currentStreak = 0;
                let bestStreak = 0;
                let tempStreak = 0;
                
                // Check backwards from today
                for (let d = new Date(today); d >= new Date(today.getFullYear(), 0, 1); d.setDate(d.getDate() - 1)) {
                    const dateKey = formatDateKey(d);
                    const dayData = userSpecificData.dayData[dateKey];
                    
                    if (dayData) {
                        // Check if day is completed (same logic as getDaysCompletedThisWeek)
                        const hasDailyIntention = dayData.dailyIntention && dayData.dailyIntention.trim() !== '';
                        const hasLeadershipRating = dayData.leadershipRating && 
                            Object.values(dayData.leadershipRating).some(rating => rating !== 5);
                        const hasGrowthQuestion = dayData.growthQuestion && dayData.growthQuestion.trim() !== '';
                        const hasCheckIn = dayData.checkIn && (
                            dayData.checkIn.emotions.length > 0 || dayData.checkIn.feeling.trim() !== ''
                        );
                        const hasGratitude = dayData.gratitude && dayData.gratitude.some(item => item.trim() !== '');
                        const hasSOAP = dayData.soap && (
                            dayData.soap.scripture.trim() !== '' || dayData.soap.observation.trim() !== '' ||
                            dayData.soap.application.trim() !== '' || dayData.soap.prayer.trim() !== ''
                        );
                        const hasDailyGoals = dayData.goals && dayData.goals.daily && 
                            dayData.goals.daily.length > 0 && dayData.goals.daily.some(goal => goal.text.trim() !== '');
                        
                        const allSections = [hasDailyIntention, hasLeadershipRating, hasGrowthQuestion, hasCheckIn, hasGratitude, hasSOAP, hasDailyGoals];
                        const meaningfulSections = allSections.filter(Boolean).length;
                        
                        if (meaningfulSections >= 3) {
                            if (d <= today) {
                                currentStreak++;
                            }
                            tempStreak++;
                            bestStreak = Math.max(bestStreak, tempStreak);
                        } else {
                            tempStreak = 0;
                            if (d < today) break; // Stop counting backwards once we hit an incomplete day
                        }
                    } else {
                        tempStreak = 0;
                        if (d < today) break;
                    }
                }
                
                return { current: currentStreak, best: bestStreak };
            };

            const getWeeklySummary = () => {
                // Ensure userSpecificData is available
                if (!userSpecificData || !userSpecificData.dayData) {
                    console.log('⚠️ [getWeeklySummary] userSpecificData not ready yet');
                    return { mvp: 'No data yet', pattern: 'Building consistency', completionRate: 0 };
                }
                
                const today = new Date();
                const startOfWeek = new Date(today);
                startOfWeek.setDate(today.getDate() - today.getDay());
                const endOfWeek = new Date(startOfWeek);
                endOfWeek.setDate(startOfWeek.getDate() + 6);
                
                let bestDay = null;
                let bestCompletion = 0;
                let mostImproved = null;
                let pattern = '';
                
                // Find best day
                for (let d = new Date(startOfWeek); d <= endOfWeek; d.setDate(d.getDate() + 1)) {
                    const dateKey = formatDateKey(d);
                    const dayData = userSpecificData.dayData[dateKey];
                    
                    if (dayData) {
                        // Calculate completion for this day
                        const sections = ['dailyIntention', 'leadershipRating', 'growthQuestion', 'checkIn', 'gratitude', 'soap', 'dailyGoals'];
                        let completedSections = 0;
                        
                        sections.forEach(section => {
                            let isCompleted = false;
                            switch (section) {
                                case 'dailyIntention':
                                    isCompleted = dayData.dailyIntention && dayData.dailyIntention.trim() !== '';
                                    break;
                                case 'leadershipRating':
                                    isCompleted = dayData.leadershipRating && 
                                        Object.values(dayData.leadershipRating).some(rating => rating !== 5);
                                    break;
                                case 'growthQuestion':
                                    isCompleted = dayData.growthQuestion && dayData.growthQuestion.trim() !== '';
                                    break;
                                case 'checkIn':
                                    isCompleted = dayData.checkIn && (
                                        dayData.checkIn.emotions.length > 0 || dayData.checkIn.feeling.trim() !== ''
                                    );
                                    break;
                                case 'gratitude':
                                    isCompleted = dayData.gratitude && dayData.gratitude.some(item => item.trim() !== '');
                                    break;
                                case 'soap':
                                    isCompleted = dayData.soap && (
                                        dayData.soap.scripture.trim() !== '' || dayData.soap.observation.trim() !== '' ||
                                        dayData.soap.application.trim() !== '' || dayData.soap.prayer.trim() !== ''
                                    );
                                    break;
                                case 'dailyGoals':
                                    isCompleted = dayData.goals && dayData.goals.daily && 
                                        dayData.goals.daily.length > 0 && dayData.goals.daily.some(goal => goal.text.trim() !== '');
                                    break;
                            }
                            if (isCompleted) completedSections++;
                        });
                        
                        const completionRate = (completedSections / sections.length) * 100;
                        if (completionRate > bestCompletion) {
                            bestCompletion = completionRate;
                            bestDay = d.toLocaleDateString('en-US', { weekday: 'long' });
                        }
                    }
                }
                
                // Simple pattern recognition
                const weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
                const weekend = ['Saturday', 'Sunday'];
                if (bestDay && weekdays.includes(bestDay)) {
                    pattern = 'Most productive on weekdays';
                } else if (bestDay && weekend.includes(bestDay)) {
                    pattern = 'Most productive on weekends';
                }
                
                return {
                    mvp: bestDay || 'No data yet',
                    pattern: pattern || 'Building consistency',
                    completionRate: Math.round(bestCompletion)
                };
            };

            const getHabitStrength = () => {
                // Ensure userSpecificData is available
                if (!userSpecificData || !userSpecificData.dayData) {
                    console.log('⚠️ [getHabitStrength] userSpecificData not ready yet');
                    return { overall: 0, category: 'Building' };
                }
                
                const completionRate = getCompletionRate();
                const overall = completionRate.overall;
                
                // Convert completion rate to habit strength (1-100)
                const habitStrength = Math.max(1, Math.min(100, overall));
                
                // Categorize habit strength
                let category = '';
                if (habitStrength >= 80) category = 'Excellent';
                else if (habitStrength >= 60) category = 'Good';
                else if (habitStrength >= 40) category = 'Fair';
                else category = 'Building';
                
                // Add debug logging
                console.log('💪 [getHabitStrength] Debug info:', {
                    completionRate,
                    overall,
                    habitStrength,
                    category
                });
                
                return {
                    overall: habitStrength,
                    category: category,
                    sections: completionRate.sections
                };
            };









            // Initialize day data
            const initializeDayData = useCallback(async () => {
                const dateKey = formatDateKey(currentDate);
                
                if (userSpecificData.dayData[dateKey]) {
                    return userSpecificData.dayData[dateKey];
                }

                setIsLoading(true);
                
                const savedData = await loadDayData(dateKey);
                
                if (savedData) {
                    setUserSpecificData(prev => ({ 
                        ...prev, 
                        dayData: { ...prev.dayData, [dateKey]: savedData } 
                    }));
                    setIsLoading(false);
                    return savedData;
                }

                // Check if we should carry over weekly/monthly goals
                let weeklyGoals = [];
                let monthlyGoals = [];
                
                // Find the most recent day with goals to check if we're in the same week/month
                const sortedDates = Object.keys(userSpecificData.dayData)
                    .sort((a, b) => new Date(b) - new Date(a));
                
                if (sortedDates.length > 0) {
                    const mostRecentDate = new Date(sortedDates[0]);
                    
                    // Check weekly goals - carry over if same week
                    if (isSameWeek(currentDate, mostRecentDate)) {
                        const recentWeeklyGoals = getMostRecentGoals('weekly');
                        if (recentWeeklyGoals.length > 0) {
                            weeklyGoals = recentWeeklyGoals.map(goal => {
                                // Check if this goal is completed anywhere in the week
                                const isCompletedAnywhere = Object.keys(userSpecificData.dayData).some(dateKey => {
                                    const dayData = userSpecificData.dayData[dateKey];
                                    const weekGoal = dayData?.goals?.weekly?.find(g => g.id === goal.id);
                                    return weekGoal?.completed;
                                });
                                
                                return {
                                    ...goal,
                                    completed: isCompletedAnywhere // Carry over completion status from other days
                                };
                            });
                        }
                    }
                    
                    // Check monthly goals - carry over if same month
                    if (isSameMonth(currentDate, mostRecentDate)) {
                        const recentMonthlyGoals = getMostRecentGoals('monthly');
                        if (recentMonthlyGoals.length > 0) {
                            monthlyGoals = recentMonthlyGoals.map(goal => {
                                // Check if this goal is completed anywhere in the month
                                const isCompletedAnywhere = Object.keys(userSpecificData.dayData).some(dateKey => {
                                    const dayData = userSpecificData.dayData[dateKey];
                                    const monthGoal = dayData?.goals?.monthly?.find(g => g.id === goal.id);
                                    return monthGoal?.completed;
                                });
                                
                                return {
                                    ...goal,
                                    completed: isCompletedAnywhere // Carry over completion status from other days
                                };
                            });
                        }
                    }
                }
                
                const newDayData = {
                    gratitude: ['', '', ''],
                    soap: {
                        scripture: '',
                        observation: '',
                        application: '',
                        prayer: ''
                    },
                    goals: {
                        daily: [],
                        weekly: weeklyGoals,
                        monthly: monthlyGoals
                    }
                };

                setUserSpecificData(prev => ({ 
                    ...prev, 
                    dayData: { ...prev.dayData, [dateKey]: newDayData } 
                }));
                await saveDayData(dateKey, newDayData);
                setIsLoading(false);
                return newDayData;
            }, [currentDate, userSpecificData.dayData]);

            // Initialize on mount
            useEffect(() => {
                initializeDatabase().then(() => {
                    initializeDayData();
                });
            }, [initializeDayData]);

            // Initialize authentication
            useEffect(() => {
                const initializeAuth = async () => {
                    try {
                        console.log('🔐 Initializing authentication...');
                        
                        // Debug: Check localStorage state before auth
                        console.log('📋 localStorage state before auth:');
                        for (let i = 0; i < localStorage.length; i++) {
                            const key = localStorage.key(i);
                            if (key && key.startsWith('dailyDavid_')) {
                                console.log('  ', key, ':', localStorage.getItem(key)?.substring(0, 100) + '...');
                            }
                        }
                        
                        // Check for stored user session (copied from working marriage meeting tool)
                        const storedAuth = localStorage.getItem('dailyDavidAuth');
                        if (storedAuth) {
                            try {
                                const authData = JSON.parse(storedAuth);
                                const { user: storedUser, timestamp } = authData;
                                
                                // Check if the stored auth is still valid (24 hours)
                                const now = Date.now();
                                const authAge = now - timestamp;
                                const maxAge = 24 * 60 * 60 * 1000; // 24 hours
                                
                                if (authAge < maxAge && storedUser && storedUser.id) {
                                    console.log('🔍 Found valid stored authentication');
                                    
                                    // Verify the user still exists in database
                                    const dbManager = new NeonDatabaseManager();
                                    const dbUser = await dbManager.getUserByEmail(storedUser.email);
                                    
                                    if (dbUser && dbUser.id === storedUser.id) {
                                        console.log('✅ Stored authentication is valid, auto-logging in');
                                        window.currentAuthenticatedUser = storedUser;
                                        
                                        if (storedUser.is_admin) {
                                            setUser(storedUser);
                                            setIsAdmin(true);
                                        } else {
                                            setUser(storedUser);
                                            setIsAdmin(false);
                                        }
                                        
                                        // Load user-specific data
                                        console.log('🔄 Loading user-specific data for user:', storedUser.id);
                                        await loadUserSpecificData(storedUser.id);
                                        
                                        setAuthLoading(false);
                                        return;
                                    } else {
                                        console.log('⚠️ Stored user no longer exists in database, clearing auth');
                                        localStorage.removeItem('dailyDavidAuth');
                                    }
                                } else {
                                    console.log('⚠️ Stored authentication expired, clearing');
                                    localStorage.removeItem('dailyDavidAuth');
                                }
                            } catch (parseError) {
                                console.log('⚠️ Invalid stored authentication, clearing');
                                localStorage.removeItem('dailyDavidAuth');
                            }
                        }
                        
                        setAuthLoading(false);
                        console.log('✅ Authentication ready - please sign in');
                    } catch (error) {
                        console.error('❌ Auth initialization error:', error);
                    } finally {
                        console.log('✅ Setting auth loading to false');
                        setAuthLoading(false);
                    }
                };

                // Neon doesn't have auth state changes like Supabase, so we handle this manually
                // The authentication is managed through localStorage and manual sign-in/sign-out

                // Add timeout to prevent infinite loading
                const authTimeout = setTimeout(() => {
                    console.log('Auth initialization timeout, forcing auth loading to false');
                    setAuthLoading(false);
                }, 15000); // 15 second timeout
                
                initializeAuth().finally(() => {
                    clearTimeout(authTimeout);
                });



                // IMMEDIATE DATA RESTORATION: Force restore data after auth initialization
                const immediateDataRestore = async () => {
                    // Wait a bit for auth to complete
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    if (user && !isAdmin) {
                        console.log('🚨 IMMEDIATE: Force restoring data after auth initialization');
                        const goalsKey = `dailyDavid_goals_${user.id}`;
                        const dayDataKey = `dailyDavid_dayData_${user.id}`;
                        const backupKey = `dailyDavid_dayData_backup_${user.id}`;
                        const emergencyKey = `dailyDavid_dayData_emergency_${user.id}`;
                        
                        console.log('🔍 IMMEDIATE: Checking localStorage keys:');
                        console.log('🔑 Goals key:', goalsKey);
                        console.log('🔑 Day data key:', dayDataKey);
                        console.log('🔑 Backup key:', backupKey);
                        console.log('🔑 Emergency key:', emergencyKey);
                        
                        const goalsData = localStorage.getItem(goalsKey);
                        const dayDataRaw = localStorage.getItem(dayDataKey);
                        const backupData = localStorage.getItem(backupKey);
                        const emergencyData = localStorage.getItem(emergencyKey);
                        
                        console.log('📊 IMMEDIATE: Found data:');
                        console.log('- Goals:', !!goalsData);
                        console.log('- Day data (primary):', !!dayDataRaw);
                        console.log('- Day data (backup):', !!backupData);
                        console.log('- Day data (emergency):', !!emergencyData);
                        
                        if (goalsData || dayDataRaw || backupData || emergencyData) {
                            console.log('🚨 IMMEDIATE: Found data, restoring now');
                            
                            let weeklyGoals = [];
                            let monthlyGoals = [];
                            let dayData = {};
                            
                            if (goalsData) {
                                try {
                                    const parsed = JSON.parse(goalsData);
                                    weeklyGoals = parsed.weeklyGoals || [];
                                    monthlyGoals = parsed.monthlyGoals || [];
                                    console.log('✅ IMMEDIATE: Goals restored');
                                } catch (error) {
                                    console.error('❌ Error parsing goals:', error);
                                }
                            }
                            
                            if (dayDataRaw) {
                                try {
                                    dayData = JSON.parse(dayDataRaw);
                                    console.log('✅ IMMEDIATE: Day data restored from primary');
                                } catch (error) {
                                    console.error('❌ Error parsing primary day data:', error);
                                }
                            } else if (backupData) {
                                try {
                                    dayData = JSON.parse(backupData);
                                    console.log('✅ IMMEDIATE: Day data restored from backup');
                                } catch (error) {
                                    console.error('❌ Error parsing backup day data:', error);
                                }
                            } else if (emergencyData) {
                                try {
                                    dayData = JSON.parse(emergencyData);
                                    console.log('✅ IMMEDIATE: Day data restored from emergency');
                                } catch (error) {
                                    console.error('❌ Error parsing emergency day data:', error);
                                }
                            }
                            
                            setUserSpecificData({
                                dayData: dayData,
                                weeklyGoals: weeklyGoals,
                                monthlyGoals: monthlyGoals
                            });
                            
                            console.log('🚨 IMMEDIATE: Data restoration complete');
                        } else {
                            console.log('⚠️ IMMEDIATE: No data found in localStorage');
                        }
                    }
                };
                
                // Run immediate data restoration after auth
                setTimeout(immediateDataRestore, 200);

                // No cleanup needed for Neon (no subscription like Supabase)
            }, []);

            // Clean up timeout
            useEffect(() => {
                return () => {
                    if (saveTimeoutRef.current) {
                        clearTimeout(saveTimeoutRef.current);
                    }
                };
            }, []);

            // Debug: Log when view changes
            useEffect(() => {
                console.log('🔄 View changed to:', currentView);
                console.log('📅 Current date:', formatDateKey(currentDate));
                console.log('📊 Current day data:', currentDayData);
                
                // AGGRESSIVE: When view changes to daily, immediately restore data if missing
                if (currentView === 'daily' && user && !isAdmin) {
                    console.log('🚨 VIEW CHANGE: Switched to daily view, checking data...');
                    
                    const hasData = Object.keys(userSpecificData.dayData).length > 0 || 
                                   userSpecificData.weeklyGoals.length > 0 || 
                                   userSpecificData.monthlyGoals.length > 0;
                    
                    if (!hasData) {
                        console.log('🚨 VIEW CHANGE: No data found, restoring immediately...');
                        
                        const goalsKey = `dailyDavid_goals_${user.id}`;
                        const dayDataKey = `dailyDavid_dayData_${user.id}`;
                        const backupKey = `dailyDavid_dayData_backup_${user.id}`;
                        const emergencyKey = `dailyDavid_dayData_emergency_${user.id}`;
                        
                        const goalsData = localStorage.getItem(goalsKey);
                        const dayDataRaw = localStorage.getItem(dayDataKey);
                        const backupData = localStorage.getItem(backupKey);
                        const emergencyData = localStorage.getItem(emergencyKey);
                        
                        if (goalsData || dayDataRaw || backupData || emergencyData) {
                            let weeklyGoals = [];
                            let monthlyGoals = [];
                            let dayData = {};
                            
                            if (goalsData) {
                                try {
                                    const parsed = JSON.parse(goalsData);
                                    weeklyGoals = parsed.weeklyGoals || [];
                                    monthlyGoals = parsed.monthlyGoals || [];
                                } catch (error) {
                                    console.error('❌ Error parsing goals:', error);
                                }
                            }
                            
                            if (dayDataRaw) {
                                try {
                                    dayData = JSON.parse(dayDataRaw);
                                } catch (error) {
                                    console.error('❌ Error parsing primary day data:', error);
                                }
                            } else if (backupData) {
                                try {
                                    dayData = JSON.parse(backupData);
                                } catch (error) {
                                    console.error('❌ Error parsing backup day data:', error);
                                }
                            } else if (emergencyData) {
                                try {
                                    dayData = JSON.parse(emergencyData);
                                } catch (error) {
                                    console.error('❌ Error parsing emergency day data:', error);
                                }
                            }
                            
                            setUserSpecificData({
                                dayData: dayData,
                                weeklyGoals: weeklyGoals,
                                monthlyGoals: monthlyGoals
                            });
                            
                            console.log('🚨 VIEW CHANGE: Data restored successfully');
                        }
                    } else {
                        console.log('🚨 VIEW CHANGE: Data already exists, no restoration needed');
                    }
                }
            }, [currentView, currentDate, currentDayData, user, isAdmin, userSpecificData.dayData, userSpecificData.weeklyGoals, userSpecificData.monthlyGoals]);

            // BULLETPROOF: Force restore data from localStorage whenever user changes
            useEffect(() => {
                if (user && !isAdmin) {
                    console.log('🔄 BULLETPROOF: User changed, forcing data restore from localStorage');
                    console.log('🔄 User ID:', user.id);
                    console.log('🔄 Current userSpecificData state:', userSpecificData);
                    
                    // Force restore data from localStorage
                    const forceRestoreData = () => {
                        try {
                            const goalsKey = `dailyDavid_goals_${user.id}`;
                            const dayDataKey = `dailyDavid_dayData_${user.id}`;
                            const backupKey = `dailyDavid_dayData_backup_${user.id}`;
                            const emergencyKey = `dailyDavid_dayData_emergency_${user.id}`;
                            
                            console.log('🔍 Checking localStorage keys:');
                            console.log('🔑 Goals key:', goalsKey);
                            console.log('🔑 Day data key:', dayDataKey);
                            console.log('🔑 Backup key:', backupKey);
                            console.log('🔑 Emergency key:', emergencyKey);
                            
                            const goalsData = localStorage.getItem(goalsKey);
                            const dayDataRaw = localStorage.getItem(dayDataKey);
                            const backupData = localStorage.getItem(backupKey);
                            const emergencyData = localStorage.getItem(emergencyKey);
                            
                            console.log('📊 Found data in localStorage:');
                            console.log('- Goals:', !!goalsData);
                            console.log('- Day data (primary):', !!dayDataRaw);
                            console.log('- Day data (backup):', !!backupData);
                            console.log('- Day data (emergency):', !!emergencyData);
                            
                            if (goalsData || dayDataRaw || backupData || emergencyData) {
                                console.log('🔄 Found data in localStorage, restoring...');
                                
                                let weeklyGoals = [];
                                let monthlyGoals = [];
                                let dayData = {};
                                
                                if (goalsData) {
                                    try {
                                        const parsed = JSON.parse(goalsData);
                                        weeklyGoals = parsed.weeklyGoals || [];
                                        monthlyGoals = parsed.monthlyGoals || [];
                                        console.log('✅ Restored goals from localStorage:', { weeklyGoals, monthlyGoals });
                                    } catch (error) {
                                        console.error('❌ Error parsing goals:', error);
                                    }
                                }
                                
                                // Try primary key first, then backup, then emergency
                                if (dayDataRaw) {
                                    try {
                                        dayData = JSON.parse(dayDataRaw);
                                        console.log('✅ Restored day data from primary localStorage:', Object.keys(dayData).length, 'dates');
                                        console.log('📅 Date keys found:', Object.keys(dayData));
                                    } catch (error) {
                                        console.error('❌ Error parsing primary day data:', error);
                                    }
                                } else if (backupData) {
                                    try {
                                        dayData = JSON.parse(backupData);
                                        console.log('✅ Restored day data from backup localStorage:', Object.keys(dayData).length, 'dates');
                                        console.log('📅 Date keys found:', Object.keys(dayData));
                                    } catch (error) {
                                        console.error('❌ Error parsing backup day data:', error);
                                    }
                                } else if (emergencyData) {
                                    try {
                                        dayData = JSON.parse(emergencyData);
                                        console.log('✅ Restored day data from emergency localStorage:', Object.keys(dayData).length, 'dates');
                                        console.log('📅 Date keys found:', Object.keys(dayData));
                                    } catch (error) {
                                        console.error('❌ Error parsing emergency day data:', error);
                                    }
                                }
                                
                                console.log('🔄 About to update userSpecificData state with:');
                                console.log('- dayData:', dayData);
                                console.log('- weeklyGoals:', weeklyGoals);
                                console.log('- monthlyGoals:', monthlyGoals);
                                
                                // Force update state
                                setUserSpecificData(prev => {
                                    const newState = {
                                        ...prev,
                                        dayData: dayData,
                                        weeklyGoals: weeklyGoals,
                                        monthlyGoals: monthlyGoals
                                    };
                                    console.log('🔄 New state will be:', newState);
                                    return newState;
                                });
                                
                                console.log('✅ BULLETPROOF: Data restored from localStorage');
                            } else {
                                console.log('⚠️ No data found in any localStorage keys');
                            }
                        } catch (error) {
                            console.error('❌ Error in force restore:', error);
                        }
                    };
                    
                    // Run immediately
                    forceRestoreData();
                    
                    // Also run after a short delay to catch any race conditions
                    setTimeout(forceRestoreData, 1000);
                    
                    // Run again after a longer delay to ensure it sticks
                    setTimeout(forceRestoreData, 3000);
                }
            }, [user?.id, isAdmin]);

            // AGGRESSIVE: Restore data when data is missing (but prevent infinite loops)
            useEffect(() => {
                if (user && !isAdmin) {
                    // Check if data is missing and restore it
                    const hasData = Object.keys(userSpecificData.dayData).length > 0 || 
                                   userSpecificData.weeklyGoals.length > 0 || 
                                   userSpecificData.monthlyGoals.length > 0;
                    
                    if (!hasData) {
                        console.log('🚨 AGGRESSIVE: No data detected, restoring from localStorage');
                        const goalsKey = `dailyDavid_goals_${user.id}`;
                        const dayDataKey = `dailyDavid_dayData_${user.id}`;
                        const backupKey = `dailyDavid_dayData_backup_${user.id}`;
                        const emergencyKey = `dailyDavid_dayData_emergency_${user.id}`;
                        
                        const goalsData = localStorage.getItem(goalsKey);
                        const dayDataRaw = localStorage.getItem(dayDataKey);
                        const backupData = localStorage.getItem(backupKey);
                        const emergencyData = localStorage.getItem(emergencyKey);
                        
                        if (goalsData || dayDataRaw || backupData || emergencyData) {
                            console.log('🚨 AGGRESSIVE: Found data in localStorage, restoring immediately');
                            
                            let weeklyGoals = [];
                            let monthlyGoals = [];
                            let dayData = {};
                            
                            if (goalsData) {
                                try {
                                    const parsed = JSON.parse(goalsData);
                                    weeklyGoals = parsed.weeklyGoals || [];
                                    monthlyGoals = parsed.monthlyGoals || [];
                                } catch (error) {
                                    console.error('❌ Error parsing goals:', error);
                                }
                            }
                            
                            if (dayDataRaw) {
                                try {
                                    dayData = JSON.parse(dayDataRaw);
                                } catch (error) {
                                    console.error('❌ Error parsing primary day data:', error);
                                }
                            } else if (backupData) {
                                try {
                                    dayData = JSON.parse(backupData);
                                } catch (error) {
                                    console.error('❌ Error parsing backup day data:', error);
                                }
                            } else if (emergencyData) {
                                try {
                                    dayData = JSON.parse(emergencyData);
                                } catch (error) {
                                    console.error('❌ Error parsing emergency day data:', error);
                                }
                            }
                            
                            setUserSpecificData({
                                dayData: dayData,
                                weeklyGoals: weeklyGoals,
                                monthlyGoals: monthlyGoals
                            });
                            
                            console.log('🚨 AGGRESSIVE: Data restored successfully');
                        }
                    }
                }
            }, [user?.id, isAdmin, userSpecificData.dayData, userSpecificData.weeklyGoals, userSpecificData.monthlyGoals]);

            // EMERGENCY: Manual data restoration function
            const emergencyRestoreData = () => {
                if (!user) return;
                
                console.log('🚨 EMERGENCY: Manual data restoration triggered');
                
                try {
                    const goalsKey = `dailyDavid_goals_${user.id}`;
                    const dayDataKey = `dailyDavid_dayData_${user.id}`;
                    const backupKey = `dailyDavid_dayData_backup_${user.id}`;
                    const emergencyKey = `dailyDavid_dayData_emergency_${user.id}`;
                    
                    console.log('🔍 Checking all localStorage keys for user:', user.id);
                    console.log('🔑 Goals key:', goalsKey);
                    console.log('🔑 Day data key:', dayDataKey);
                    console.log('🔑 Backup key:', backupKey);
                    console.log('🔑 Emergency key:', emergencyKey);
                    
                    const goalsData = localStorage.getItem(goalsKey);
                    const dayDataRaw = localStorage.getItem(dayDataKey);
                    const backupData = localStorage.getItem(backupKey);
                    const emergencyData = localStorage.getItem(emergencyKey);
                    
                    console.log('📊 Found data:');
                    console.log('- Goals:', !!goalsData);
                    console.log('- Day data (primary):', !!dayDataRaw);
                    console.log('- Day data (backup):', !!backupData);
                    console.log('- Day data (emergency):', !!emergencyData);
                    
                    let weeklyGoals = [];
                    let monthlyGoals = [];
                    let dayData = {};
                    
                    // Restore goals
                    if (goalsData) {
                        try {
                            const parsed = JSON.parse(goalsData);
                            weeklyGoals = parsed.weeklyGoals || [];
                            monthlyGoals = parsed.monthlyGoals || [];
                            console.log('✅ Emergency restored goals:', { weeklyGoals, monthlyGoals });
                        } catch (error) {
                            console.error('❌ Error parsing goals:', error);
                        }
                    }
                    
                    // Restore day data (try all keys)
                    if (dayDataRaw) {
                        try {
                            dayData = JSON.parse(dayDataRaw);
                            console.log('✅ Emergency restored day data from primary:', Object.keys(dayData).length, 'dates');
                        } catch (error) {
                            console.error('❌ Error parsing primary day data:', error);
                        }
                    } else if (backupData) {
                        try {
                            dayData = JSON.parse(backupData);
                            console.log('✅ Emergency restored day data from backup:', Object.keys(dayData).length, 'dates');
                        } catch (error) {
                            console.error('❌ Error parsing backup day data:', error);
                        }
                    } else if (emergencyData) {
                        try {
                            dayData = JSON.parse(emergencyData);
                            console.log('✅ Emergency restored day data from emergency:', Object.keys(dayData).length, 'dates');
                        } catch (error) {
                            console.error('❌ Error parsing emergency day data:', error);
                        }
                    }
                    
                    // Force update state
                    setUserSpecificData({
                        dayData: dayData,
                        weeklyGoals: weeklyGoals,
                        monthlyGoals: monthlyGoals
                    });
                    
                    console.log('🚨 EMERGENCY: Data restoration complete');
                    console.log('📊 Final state - dayData keys:', Object.keys(dayData));
                    console.log('📊 Final state - weeklyGoals count:', weeklyGoals.length);
                    console.log('📊 Final state - monthlyGoals count:', monthlyGoals.length);
                    
                } catch (error) {
                    console.error('❌ CRITICAL ERROR in emergency restore:', error);
                }
            };

            // GLOBAL DATA MONITORING: Track when userSpecificData changes
            useEffect(() => {
                if (user && !isAdmin) {
                    console.log('🔍 GLOBAL MONITOR: userSpecificData state changed');
                    console.log('🔍 New state:', userSpecificData);
                    console.log('🔍 Day data keys:', Object.keys(userSpecificData.dayData));
                    console.log('🔍 Weekly goals count:', userSpecificData.weeklyGoals.length);
                    console.log('🔍 Monthly goals count:', userSpecificData.monthlyGoals.length);
                    
                    // Check if data was cleared unexpectedly
                    if (Object.keys(userSpecificData.dayData).length === 0 && 
                        userSpecificData.weeklyGoals.length === 0 && 
                        userSpecificData.monthlyGoals.length === 0) {
                        console.log('🚨 WARNING: All data appears to be cleared!');
                        console.log('🚨 This might indicate data is being reset somewhere');
                        
                        // Try to restore from localStorage immediately
                        setTimeout(() => {
                            console.log('🚨 Attempting emergency restore due to data clearing...');
                            emergencyRestoreData();
                        }, 100);
                    }
                }
            }, [userSpecificData, user, isAdmin]);

            // CONSTANT DATA RESTORATION: Force restore data on every render when needed
            useEffect(() => {
                if (user && !isAdmin) {
                    // Check if we have data in localStorage but not in state
                    const goalsKey = `dailyDavid_goals_${user.id}`;
                    const dayDataKey = `dailyDavid_dayData_${user.id}`;
                    const backupKey = `dailyDavid_dayData_backup_${user.id}`;
                    const emergencyKey = `dailyDavid_dayData_emergency_${user.id}`;
                    
                    const goalsData = localStorage.getItem(goalsKey);
                    const dayDataRaw = localStorage.getItem(dayDataKey);
                    const backupData = localStorage.getItem(backupKey);
                    const emergencyData = localStorage.getItem(emergencyKey);
                    
                    const hasLocalStorageData = goalsData || dayDataRaw || backupData || emergencyData;
                    const hasStateData = Object.keys(userSpecificData.dayData).length > 0 || 
                                       userSpecificData.weeklyGoals.length > 0 || 
                                       userSpecificData.monthlyGoals.length > 0;
                    
                    if (hasLocalStorageData && !hasStateData) {
                        console.log('🚨 CONSTANT: localStorage has data but state is empty, restoring...');
                        
                        let weeklyGoals = [];
                        let monthlyGoals = [];
                        let dayData = {};
                        
                        if (goalsData) {
                            try {
                                const parsed = JSON.parse(goalsData);
                                weeklyGoals = parsed.weeklyGoals || [];
                                monthlyGoals = parsed.monthlyGoals || [];
                            } catch (error) {
                                console.error('❌ Error parsing goals:', error);
                            }
                        }
                        
                        if (dayDataRaw) {
                            try {
                                dayData = JSON.parse(dayDataRaw);
                            } catch (error) {
                                console.error('❌ Error parsing primary day data:', error);
                            }
                        } else if (backupData) {
                            try {
                                dayData = JSON.parse(backupData);
                            } catch (error) {
                                console.error('❌ Error parsing backup day data:', error);
                            }
                        } else if (emergencyData) {
                            try {
                                dayData = JSON.parse(emergencyData);
                            } catch (error) {
                                console.error('❌ Error parsing emergency day data:', error);
                            }
                        }
                        
                        setUserSpecificData({
                            dayData: dayData,
                            weeklyGoals: weeklyGoals,
                            monthlyGoals: monthlyGoals
                        });
                        
                        console.log('🚨 CONSTANT: Data restored successfully');
                    }
                }
            });

            // AGGRESSIVE: Check and restore data on EVERY render
            const aggressiveDataCheck = () => {
                if (user && !isAdmin) {
                    const goalsKey = `dailyDavid_goals_${user.id}`;
                    const dayDataKey = `dailyDavid_dayData_${user.id}`;
                    const backupKey = `dailyDavid_dayData_backup_${user.id}`;
                    const emergencyKey = `dailyDavid_dayData_emergency_${user.id}`;
                    
                    const goalsData = localStorage.getItem(goalsKey);
                    const dayDataRaw = localStorage.getItem(dayDataKey);
                    const backupData = localStorage.getItem(backupKey);
                    const emergencyData = localStorage.getItem(emergencyKey);
                    
                    const hasLocalStorageData = goalsData || dayDataRaw || backupData || emergencyData;
                    const hasStateData = Object.keys(userSpecificData.dayData).length > 0 || 
                                       userSpecificData.weeklyGoals.length > 0 || 
                                       userSpecificData.monthlyGoals.length > 0;
                    
                    if (hasLocalStorageData && !hasStateData) {
                        console.log('🚨 AGGRESSIVE: Data missing on render, restoring immediately');
                        
                        let weeklyGoals = [];
                        let monthlyGoals = [];
                        let dayData = {};
                        
                        if (goalsData) {
                            try {
                                const parsed = JSON.parse(goalsData);
                                weeklyGoals = parsed.weeklyGoals || [];
                                monthlyGoals = parsed.monthlyGoals || [];
                            } catch (error) {
                                console.error('❌ Error parsing goals:', error);
                            }
                        }
                        
                        if (dayDataRaw) {
                            try {
                                dayData = JSON.parse(dayDataRaw);
                            } catch (error) {
                                console.error('❌ Error parsing primary day data:', error);
                            }
                        } else if (backupData) {
                            try {
                                dayData = JSON.parse(backupData);
                            } catch (error) {
                                console.error('❌ Error parsing backup day data:', error);
                            }
                        } else if (emergencyData) {
                            try {
                                dayData = JSON.parse(emergencyData);
                            } catch (error) {
                                console.error('❌ Error parsing emergency day data:', error);
                            }
                        }
                        
                        setUserSpecificData({
                            dayData: dayData,
                            weeklyGoals: weeklyGoals,
                            monthlyGoals: monthlyGoals
                        });
                        
                        console.log('🚨 AGGRESSIVE: Data restored on render');
                    }
                }
            };
            
            // Call aggressive check on every render
            aggressiveDataCheck();
            
            // ULTRA AGGRESSIVE: Check data on every render when in daily view
            if (currentView === 'daily' && user && !isAdmin) {
                const hasData = Object.keys(userSpecificData.dayData).length > 0 || 
                               userSpecificData.weeklyGoals.length > 0 || 
                               userSpecificData.monthlyGoals.length > 0;
                
                if (!hasData) {
                    console.log('🚨 ULTRA AGGRESSIVE: In daily view with no data, restoring immediately');
                    
                    const goalsKey = `dailyDavid_goals_${user.id}`;
                    const dayDataKey = `dailyDavid_dayData_${user.id}`;
                    const backupKey = `dailyDavid_dayData_backup_${user.id}`;
                    const emergencyKey = `dailyDavid_dayData_emergency_${user.id}`;
                    
                    const goalsData = localStorage.getItem(goalsKey);
                    const dayDataRaw = localStorage.getItem(dayDataKey);
                    const backupData = localStorage.getItem(backupKey);
                    const emergencyData = localStorage.getItem(emergencyKey);
                    
                    if (goalsData || dayDataRaw || backupData || emergencyData) {
                        let weeklyGoals = [];
                        let monthlyGoals = [];
                        let dayData = {};
                        
                        if (goalsData) {
                            try {
                                const parsed = JSON.parse(goalsData);
                                weeklyGoals = parsed.weeklyGoals || [];
                                monthlyGoals = parsed.monthlyGoals || [];
                            } catch (error) {
                                console.error('❌ Error parsing goals:', error);
                            }
                        }
                        
                        if (dayDataRaw) {
                            try {
                                dayData = JSON.parse(dayDataRaw);
                            } catch (error) {
                                console.error('❌ Error parsing primary day data:', error);
                            }
                        } else if (backupData) {
                            try {
                                dayData = JSON.parse(backupData);
                            } catch (error) {
                                console.error('❌ Error parsing backup day data:', error);
                            }
                        } else if (emergencyData) {
                            try {
                                dayData = JSON.parse(emergencyData);
                            } catch (error) {
                                console.error('❌ Error parsing emergency day data:', error);
                            }
                        }
                        
                        setUserSpecificData({
                            dayData: dayData,
                            weeklyGoals: weeklyGoals,
                            monthlyGoals: monthlyGoals
                        });
                        
                        console.log('🚨 ULTRA AGGRESSIVE: Data restored on render');
                    }
                }
            }

            // DEBUG: Track ALL state changes to find what's clearing data
            useEffect(() => {
                console.log('🔍 DEBUG: userSpecificData changed - Stack trace:');
                console.trace('userSpecificData change stack trace');
                
                if (user && !isAdmin) {
                    console.log('🔍 DEBUG: Current userSpecificData state:', userSpecificData);
                    console.log('🔍 DEBUG: Day data keys:', Object.keys(userSpecificData.dayData));
                    console.log('🔍 DEBUG: Weekly goals count:', userSpecificData.weeklyGoals.length);
                    console.log('🔍 DEBUG: Monthly goals count:', userSpecificData.monthlyGoals.length);
                    
                    // Check if data was just cleared
                    if (Object.keys(userSpecificData.dayData).length === 0 && 
                        userSpecificData.weeklyGoals.length === 0 && 
                        userSpecificData.monthlyGoals.length === 0) {
                        console.log('🚨 DEBUG: DATA WAS JUST CLEARED!');
                        console.log('🚨 DEBUG: This happened after the previous state change');
                        console.log('🚨 DEBUG: Previous state should have had data');
                        
                        // Check localStorage to see if data still exists there
                        const goalsKey = `dailyDavid_goals_${user.id}`;
                        const dayDataKey = `dailyDavid_dayData_${user.id}`;
                        const backupKey = `dailyDavid_dayData_backup_${user.id}`;
                        const emergencyKey = `dailyDavid_dayData_emergency_${user.id}`;
                        
                        const goalsData = localStorage.getItem(goalsKey);
                        const dayDataRaw = localStorage.getItem(dayDataKey);
                        const backupData = localStorage.getItem(backupKey);
                        const emergencyData = localStorage.getItem(emergencyKey);
                        
                        console.log('🔍 DEBUG: localStorage state when data was cleared:');
                        console.log('- Goals:', !!goalsData);
                        console.log('- Day data (primary):', !!goalsData);
                        console.log('- Day data (backup):', !!backupData);
                        console.log('- Day data (emergency):', !!emergencyData);
                        
                        if (goalsData || dayDataRaw || backupData || emergencyData) {
                            console.log('🚨 DEBUG: localStorage STILL HAS DATA but state was cleared!');
                            console.log('🚨 DEBUG: This means something is clearing the React state');
                            
                            // PREVENT DATA CLEARING: Immediately restore data if it was cleared
                            console.log('🚨 PREVENTING DATA CLEARING: Restoring data immediately');
                            
                            let weeklyGoals = [];
                            let monthlyGoals = [];
                            let dayData = {};
                            
                            if (goalsData) {
                                try {
                                    const parsed = JSON.parse(goalsData);
                                    weeklyGoals = parsed.weeklyGoals || [];
                                    monthlyGoals = parsed.monthlyGoals || [];
                                } catch (error) {
                                    console.error('❌ Error parsing goals:', error);
                                }
                            }
                            
                            if (dayDataRaw) {
                                try {
                                    dayData = JSON.parse(dayDataRaw);
                                } catch (error) {
                                    console.error('❌ Error parsing primary day data:', error);
                                }
                            } else if (backupData) {
                                try {
                                    dayData = JSON.parse(backupData);
                                } catch (error) {
                                    console.error('❌ Error parsing backup day data:', error);
                                }
                            } else if (emergencyData) {
                                try {
                                    dayData = JSON.parse(emergencyData);
                                } catch (error) {
                                    console.error('❌ Error parsing emergency day data:', error);
                                }
                            }
                            
                            // Force restore the data
                            setUserSpecificData({
                                dayData: dayData,
                                weeklyGoals: weeklyGoals,
                                monthlyGoals: monthlyGoals
                            });
                            
                            console.log('🚨 DATA CLEARING PREVENTED: Data restored successfully');
                        } else {
                            console.log('🚨 DEBUG: localStorage was also cleared!');
                            console.log('🚨 DEBUG: This means something is clearing localStorage');
                        }
                    }
                }
            }, [userSpecificData, user, isAdmin]);

            // NEW: Track UI rendering to see if data is being used correctly
            useEffect(() => {
                if (user && !isAdmin && currentView === 'daily') {
                    console.log('🎯 UI RENDERING DEBUG: Daily view is rendering');
                    console.log('🎯 UI RENDERING DEBUG: currentDayData:', currentDayData);
                    console.log('🎯 UI RENDERING DEBUG: userSpecificData.dayData keys:', Object.keys(userSpecificData.dayData));
                    console.log('🎯 UI RENDERING DEBUG: Current date:', currentDate);
                    console.log('🎯 UI RENDERING DEBUG: Date key:', formatDateKey(currentDate));
                    
                    // Check if the UI is getting the right data
                    const dateKey = formatDateKey(currentDate);
                    const expectedData = userSpecificData.dayData[dateKey];
                    const actualData = currentDayData;
                    
                    console.log('🎯 UI RENDERING DEBUG: Expected data for date:', !!expectedData);
                    console.log('🎯 UI RENDERING DEBUG: Actual data from currentDayData:', !!actualData);
                    console.log('🎯 UI RENDERING DEBUG: Data match:', expectedData === actualData);
                    
                    if (!actualData || Object.keys(actualData).length === 0) {
                        console.log('🚨 UI RENDERING ERROR: currentDayData is empty but should have data!');
                        console.log('🚨 UI RENDERING ERROR: This explains why the UI shows nothing!');
                        
                        // Force restore the specific date data
                        if (expectedData) {
                            console.log('🚨 UI RENDERING FIX: Restoring data for specific date');
                            setUserSpecificData(prev => ({
                                ...prev,
                                dayData: { ...prev.dayData, [dateKey]: expectedData }
                            }));
                        }
                    }
                }
            }, [currentView, currentDate, currentDayData, userSpecificData.dayData, user, isAdmin]);

            // CRITICAL FIX: Ensure UI components always have access to the right data
            useEffect(() => {
                if (user && !isAdmin && currentView === 'daily') {
                    const dateKey = formatDateKey(currentDate);
                    const expectedData = userSpecificData.dayData[dateKey];
                    
                    // If we're in daily view but don't have data for the current date, restore it
                    if (!expectedData && Object.keys(userSpecificData.dayData).length > 0) {
                        console.log('🚨 CRITICAL FIX: Missing data for daily view date:', dateKey);
                        console.log('🚨 CRITICAL FIX: Available dates:', Object.keys(userSpecificData.dayData));
                        
                        // Try to get data from localStorage for this specific date
                        const dayDataKey = `dailyDavid_dayData_${user.id}`;
                        const dayDataRaw = localStorage.getItem(dayDataKey);
                        
                        if (dayDataRaw) {
                            try {
                                const dayData = JSON.parse(dayDataRaw);
                                if (dayData[dateKey]) {
                                    console.log('🚨 CRITICAL FIX: Found data in localStorage for date:', dateKey);
                                    console.log('🚨 CRITICAL FIX: Restoring to state');
                                    
                                    setUserSpecificData(prev => ({
                                        ...prev,
                                        dayData: { ...prev.dayData, [dateKey]: dayData[dateKey] }
                                    }));
                                }
                            } catch (error) {
                                console.error('❌ Error parsing day data for critical fix:', error);
                            }
                        }
                    }
                }
            }, [currentView, currentDate, userSpecificData.dayData, user, isAdmin]);

            // FINAL DEBUG: Track what the UI components are actually receiving
            useEffect(() => {
                if (user && !isAdmin && currentView === 'daily' && currentDayData) {
                    console.log('🎯 FINAL DEBUG: UI Components should be receiving this data:');
                    console.log('🎯 FINAL DEBUG: currentDayData.gratitude:', currentDayData.gratitude);
                    console.log('🎯 FINAL DEBUG: currentDayData.soap:', currentDayData.soap);
                    console.log('🎯 FINAL DEBUG: currentDayData.goals:', currentDayData.goals);
                    console.log('🎯 FINAL DEBUG: currentDayData.gratitude.length:', currentDayData.gratitude?.length);
                    console.log('🎯 FINAL DEBUG: currentDayData.soap.thoughts:', currentDayData.soap?.thoughts);
                    console.log('🎯 FINAL DEBUG: currentDayData.goals.daily:', currentDayData.goals?.daily);
                    
                    // Check if the data structure is correct
                    if (currentDayData.gratitude && Array.isArray(currentDayData.gratitude)) {
                        console.log('✅ FINAL DEBUG: Gratitude array is valid, length:', currentDayData.gratitude.length);
                        currentDayData.gratitude.forEach((item, index) => {
                            console.log(`✅ FINAL DEBUG: Gratitude[${index}]:`, item);
                        });
                    } else {
                        console.log('❌ FINAL DEBUG: Gratitude is NOT valid:', currentDayData.gratitude);
                    }
                    
                    if (currentDayData.soap && typeof currentDayData.soap === 'object') {
                        console.log('✅ FINAL DEBUG: SOAP object is valid:', currentDayData.soap);
                    } else {
                        console.log('❌ FINAL DEBUG: SOAP is NOT valid:', currentDayData.soap);
                    }
                    
                    if (currentDayData.goals && typeof currentDayData.goals === 'object') {
                        console.log('✅ FINAL DEBUG: Goals object is valid:', currentDayData.goals);
                    } else {
                        console.log('❌ FINAL DEBUG: Goals is NOT valid:', currentDayData.goals);
                    }
                }
            }, [currentView, currentDayData, user, isAdmin]);

            // IMMEDIATE DATA CLEARING DETECTION: Check if data is cleared immediately after being set
            const prevStateRef = useRef(userSpecificData);
            
            useEffect(() => {
                if (user && !isAdmin) {
                    // Check if data was just set and then immediately cleared
                    const prevHasData = Object.keys(prevStateRef.current.dayData).length > 0 || 
                                       prevStateRef.current.weeklyGoals.length > 0 || 
                                       prevStateRef.current.monthlyGoals.length > 0;
                    
                    const currentHasData = Object.keys(userSpecificData.dayData).length > 0 || 
                                         userSpecificData.weeklyGoals.length > 0 || 
                                         userSpecificData.monthlyGoals.length > 0;
                    
                    if (prevHasData && !currentHasData) {
                        console.log('🚨 IMMEDIATE CLEARING DETECTED!');
                        console.log('🚨 Data was just set and then immediately cleared!');
                        console.log('🚨 Previous state had data, current state is empty');
                        console.log('🚨 This suggests a race condition or conflicting effect');
                        
                        // Check what effects are running
                        console.log('🚨 Checking for conflicting effects...');
                        
                        // Force immediate restoration
                        setTimeout(() => {
                            console.log('🚨 Attempting immediate restoration after clearing detection...');
                            emergencyRestoreData();
                        }, 0);
                    }
                    
                    // Update the ref for next comparison
                    prevStateRef.current = userSpecificData;
                }
            }, [userSpecificData, user, isAdmin]);

            // TRACK ALL EFFECTS: Monitor when effects run to find the culprit
            useEffect(() => {
                console.log('🔍 TRACK: Effect with userSpecificData dependency ran');
                console.log('🔍 TRACK: Current userSpecificData:', userSpecificData);
                console.log('🔍 TRACK: Stack trace for this effect:');
                console.trace('Effect with userSpecificData dependency');
            }, [userSpecificData]);

            // TRACK USER CHANGES: Monitor when user state changes
            useEffect(() => {
                console.log('🔍 TRACK: User state changed');
                console.log('🔍 TRACK: New user:', user);
                console.log('🔍 TRACK: Is admin:', isAdmin);
                console.log('🔍 TRACK: Stack trace for user change:');
                console.trace('User state change');
            }, [user, isAdmin]);

            // TRACK AUTH LOADING: Monitor auth loading state
            useEffect(() => {
                console.log('🔍 TRACK: Auth loading state changed:', authLoading);
                console.log('🔍 TRACK: Stack trace for auth loading change:');
                console.trace('Auth loading change');
            }, [authLoading]);

            // Use the currentDayData from the useDayData hook instead of useMemo

            // Update functions
            const updateGratitude = (index, value) => {
                // Update the hook's dayData directly (this will auto-save to Neon)
                setCurrentDayData(prevData => {
                    if (!prevData) return prevData;
                    
                    const newData = {
                        ...prevData,
                        gratitude: prevData.gratitude.map((item, i) => i === index ? value : item)
                    };
                    
                    // Also update localStorage for backup
                    if (user && user.id) {
                        const dayDataKey = `dailyDavid_dayData_${user.id}`;
                        const allDayData = { ...userSpecificData.dayData, [currentDateKey]: newData };
                        localStorage.setItem(dayDataKey, JSON.stringify(allDayData));
                    }
                    
                    return newData;
                });
            };

            const updateSOAP = (section, value) => {
                // Update the hook's dayData directly (this will auto-save to Neon)
                setCurrentDayData(prevData => {
                    if (!prevData) return prevData;
                    
                    const newData = {
                        ...prevData,
                        soap: {
                            ...prevData.soap,
                            [section]: value
                        }
                    };
                    
                    // Also update localStorage for backup
                    if (user && user.id) {
                        const dayDataKey = `dailyDavid_dayData_${user.id}`;
                        const allDayData = { ...userSpecificData.dayData, [currentDateKey]: newData };
                        localStorage.setItem(dayDataKey, JSON.stringify(allDayData));
                    }
                    
                    return newData;
                });
            };

            const updateCheckIn = (checkInData) => {
                // Update the hook's dayData directly (this will auto-save to Neon)
                setCurrentDayData(prevData => {
                    if (!prevData) return prevData;
                    
                    const newData = {
                        ...prevData,
                        checkIn: checkInData
                    };
                    
                    // Also update localStorage for backup
                    if (user && user.id) {
                        const dayDataKey = `dailyDavid_dayData_${user.id}`;
                        const allDayData = { ...userSpecificData.dayData, [currentDateKey]: newData };
                        localStorage.setItem(dayDataKey, JSON.stringify(allDayData));
                    }
                    
                    // Trigger debounced save to Neon database
                    if (user && user.id) {
                        debouncedSave(currentDateKey, newData);
                    }
                    
                    return newData;
                });
            };

            const updateDailyIntention = (intention) => {
                setCurrentDayData(prevData => {
                    if (!prevData) return prevData;
                    
                    const newData = {
                        ...prevData,
                        dailyIntention: intention
                    };
                    
                    // Also update localStorage for backup
                    if (user && user.id) {
                        const dayDataKey = `dailyDavid_dayData_${user.id}`;
                        const allDayData = { ...userSpecificData.dayData, [currentDateKey]: newData };
                        localStorage.setItem(dayDataKey, JSON.stringify(allDayData));
                    }
                    
                    // Trigger debounced save to Neon database
                    if (user && user.id) {
                        debouncedSave(currentDateKey, newData);
                    }
                    
                    return newData;
                });
            };

            const updateLeadershipRating = (trait, rating) => {
                setCurrentDayData(prevData => {
                    if (!prevData) return prevData;
                    
                    const newData = {
                        ...prevData,
                        leadershipRating: {
                            ...prevData.leadershipRating,
                            [trait]: rating
                        }
                    };
                    
                    // Also update localStorage for backup
                    if (user && user.id) {
                        const dayDataKey = `dailyDavid_dayData_${user.id}`;
                        const allDayData = { ...userSpecificData.dayData, [currentDateKey]: newData };
                        localStorage.setItem(dayDataKey, JSON.stringify(allDayData));
                    }
                    
                    // Trigger debounced save to Neon database
                    if (user && user.id) {
                        debouncedSave(currentDateKey, newData);
                    }
                    
                    return newData;
                });
            };

            const updateGrowthQuestion = (question) => {
                setCurrentDayData(prevData => {
                    if (!prevData) return prevData;
                    
                    const newData = {
                        ...prevData,
                        growthQuestion: question
                    };
                    
                    // Also update localStorage for backup
                    if (user && user.id) {
                        const dayDataKey = `dailyDavid_dayData_${user.id}`;
                        const allDayData = { ...userSpecificData.dayData, [currentDateKey]: newData };
                        localStorage.setItem(dayDataKey, JSON.stringify(allDayData));
                    }
                    
                    // Trigger debounced save to Neon database
                    if (user && user.id) {
                        debouncedSave(currentDateKey, newData);
                    }
                    
                    return newData;
                });
            };

                            // Removed duplicate goal functions - using addGoal, updateGoal, etc. instead

            const navigateDate = (direction) => {
                const newDate = new Date(currentDate);
                newDate.setDate(newDate.getDate() + direction);
                setCurrentDate(newDate);
                
                // Check if we need to update goals for the new date
                setTimeout(() => {
                    updateGoalsForDate(newDate);
                }, 100);
            };

            const updateGoalsForDate = (targetDate) => {
                const dateKey = formatDateKey(targetDate);
                console.log('🔄 DEBUG: updateGoalsForDate called for date:', dateKey);
                
                // Use our new ensureGoalsCarryOver function
                ensureGoalsCarryOver(dateKey);
                
                // Also run the existing logic as a backup
                const existingData = userSpecificData.dayData[dateKey];
                
                if (!existingData) {
                    console.log('🔄 DEBUG: No existing data for date:', dateKey);
                    return;
                }
                
                console.log('🔄 DEBUG: Existing goals for date:', dateKey, existingData.goals);
                
                let needsUpdate = false;
                let updatedGoals = { ...existingData.goals };
                
                // Check weekly goals
                const sortedDates = Object.keys(userSpecificData.dayData)
                    .sort((a, b) => new Date(b) - new Date(a));
                
                if (sortedDates.length > 0) {
                    const mostRecentDate = new Date(sortedDates[0]);
                    console.log('🔄 DEBUG: Most recent date:', mostRecentDate);
                    
                    // Update weekly goals if same week
                    if (isSameWeek(targetDate, mostRecentDate)) {
                        const recentWeeklyGoals = getMostRecentGoals('weekly');
                        console.log('🔄 DEBUG: Recent weekly goals:', recentWeeklyGoals);
                        if (recentWeeklyGoals.length > 0 && 
                            JSON.stringify(recentWeeklyGoals) !== JSON.stringify(existingData.goals.weekly)) {
                            updatedGoals.weekly = recentWeeklyGoals.map(goal => ({
                                ...goal,
                                completed: existingData.goals.weekly.find(g => g.id === goal.id)?.completed || false
                            }));
                            needsUpdate = true;
                            console.log('🔄 DEBUG: Updated weekly goals:', updatedGoals.weekly);
                        }
                    }
                    
                    // Update monthly goals if same month
                    if (isSameMonth(targetDate, mostRecentDate)) {
                        const recentMonthlyGoals = getMostRecentGoals('monthly');
                        console.log('🔄 DEBUG: Recent monthly goals:', recentMonthlyGoals);
                        if (recentMonthlyGoals.length > 0 && 
                            JSON.stringify(recentMonthlyGoals) !== JSON.stringify(existingData.goals.monthly)) {
                            updatedGoals.monthly = recentMonthlyGoals.map(goal => ({
                                ...goal,
                                completed: existingData.goals.monthly.find(g => g.id === goal.id)?.completed || false
                            }));
                            needsUpdate = true;
                            console.log('🔄 DEBUG: Updated monthly goals:', updatedGoals.monthly);
                        }
                    }
                }
                
                // Save updated goals if needed
                if (needsUpdate) {
                    const updatedDayData = {
                        ...existingData,
                        goals: updatedGoals
                    };
                    
                    const dayDataKey = `dailyDavid_dayData_${user.id}`;
                    const allDayData = { ...userSpecificData.dayData, [dateKey]: updatedDayData };
                    localStorage.setItem(dayDataKey, JSON.stringify(allDayData));
                    
                    setUserSpecificData(prev => ({
                        ...prev,
                        dayData: { ...prev.dayData, [dateKey]: updatedDayData }
                    }));
                    
                    console.log('🔄 DEBUG: Goals updated and saved for date:', dateKey);
                }
            };

            // Show loading while auth is initializing
            if (authLoading) {
                return (
                    <div className="flex items-center justify-center min-h-screen">
                        <div className="text-center">
                            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary mx-auto mb-4"></div>
                            <p className="text-gray-600">Initializing...</p>
                        </div>
                    </div>
                );
            }

            // Show sign-in screen if not authenticated
            if (!user) {
                return (
                    <SignInScreen 
                        onSignIn={handleSignIn}
                        onAdminSignIn={handleAdminSignIn}
                    />
                );
            }

            // Show admin panel if user is admin
            if (isAdmin) {
                return (
                                            <AdminPanel 
                            user={user}
                            onSignOut={handleSignOut}
                            onAddUser={handleAddUser}
                            onRemoveUser={handleRemoveUser}
                            useServiceRoleKey={true}
                        />
                );
            }

            // Show loading while app data is loading
            if (isLoading) {
                return (
                    <div className="flex items-center justify-center min-h-screen">
                        <div className="text-center">
                            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary mx-auto mb-4"></div>
                            <p className="text-gray-600">Loading your daily devotions...</p>
                        </div>
                    </div>
                );
            }

            return (
                <div className="container mx-auto px-4 py-8 max-w-6xl">
                    {/* Header Section */}
                    <div className="section-card rounded-xl p-6 mb-8">
                        <div className="flex flex-col md:flex-row items-center justify-between gap-4">
                            <div className="text-center md:text-left">
                                <h1 className="section-header text-4xl font-bold mb-2 flex items-center gap-3">
                                    <BookOpenIcon />
                                    The Daily David
                                </h1>
                                <p className="text-gray-600 text-lg">
                                    Grow in faith, gratitude, and purpose
                                </p>
                            </div>
                            
                            <div className="flex items-center gap-4">
                                <div className="text-right text-sm">
                                    <div className={`flex items-center gap-2 ${
                                        isConnected ? 'text-green-600' : 'text-red-600'
                                    }`}>
                                        <div className={`w-2 h-2 rounded-full ${
                                            isConnected ? 'bg-green-500' : 'bg-red-500'
                                        } status-indicator`}></div>
                                        {isConnected ? 'Synced' : 'Offline'}
                                    </div>
                                    {lastSaved && (
                                        <div className="text-gray-500">
                                            Last saved: {lastSaved.toLocaleTimeString()}
                                        </div>
                                    )}
                                    
                                    {/* Data persistence status removed - was confusing */}
                                </div>
                                
                                {/* User Info and Sign Out */}
                                <div className="flex items-center gap-3">
                                    <div className="text-sm text-gray-600">
                                        Welcome, {user.email}
                                        {!isAdmin && <span className="ml-2 text-blue-600">👤 User Mode</span>}
                                    </div>

                                    {/* Data Recovery Button - only show if there might be an issue */}
                                    {!isAdmin && (() => {
                                        // Only show if user has no data or very little data
                                        const hasData = Object.keys(userSpecificData.dayData).length > 0 || 
                                                      userSpecificData.weeklyGoals.length > 0 || 
                                                      userSpecificData.monthlyGoals.length > 0;
                                        return !hasData;
                                    })() && (
                                        <button 
                                            onClick={emergencyRestoreData}
                                            className="px-3 py-1 bg-orange-500 text-white text-sm rounded-lg hover:bg-orange-600 transition-colors"
                                            title="Recover data if something went wrong"
                                        >
                                            🔄 Recover Data
                                        </button>
                                    )}

                                    <button 
                                        onClick={handleSignOut}
                                        className="px-3 py-1 bg-red-500 text-white text-sm rounded-lg hover:bg-red-600 transition-colors"
                                    >
                                        Sign Out
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div className="section-divider"></div>



                        {/* View Navigation */}
                        <div className="flex items-center justify-center gap-4 mb-6">
                            <button
                                onClick={() => setCurrentViewWithPersistence('landing')}
                                className={`px-6 py-2 rounded-lg font-medium transition-colors ${
                                    currentView === 'landing'
                                        ? 'bg-primary text-white shadow-md'
                                        : 'bg-gray-200 text-gray-600 hover:bg-gray-200'
                                }`}
                            >
                                🏠 Dashboard
                            </button>
                            <button
                                onClick={() => setCurrentViewWithPersistence('daily')}
                                className={`px-6 py-2 rounded-lg font-medium transition-colors ${
                                    currentView === 'daily'
                                        ? 'bg-primary text-white shadow-md'
                                        : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                                }`}
                            >
                                ✍️ Daily Entry
                            </button>
                        </div>

                        {/* Date Navigation */}
                        <div className="flex items-center justify-center gap-6">
                            <button 
                                onClick={() => navigateDate(-1)}
                                className="flex items-center gap-2 px-4 py-2 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors shadow-sm"
                            >
                                <ChevronLeftIcon />
                                Previous Day
                            </button>
                            
                            <div className="text-center">
                                <h2 className="text-xl font-semibold text-gray-800">
                                    {formatDateDisplay(currentDate)}
                                </h2>
                                <p className="text-sm text-gray-500 mt-1">
                                    Day {Math.ceil((currentDate - new Date(currentDate.getFullYear(), 0, 1)) / (1000 * 60 * 60 * 24))} of {currentDate.getFullYear()}
                                </p>
                            </div>
                            
                            <button 
                                onClick={() => navigateDate(1)}
                                className="flex items-center gap-2 px-4 py-2 bg-white border border-gray-300 rounded-lg hover:bg-gray-50 transition-colors shadow-sm"
                            >
                                Next Day
                                <ChevronRightIcon />
                            </button>
                        </div>
                    </div>

                    {/* Conditional Rendering Based on View */}
                    {(() => {
                        console.log('🎯 VIEW RENDERING DEBUG: Current view:', currentView);
                        console.log('🎯 VIEW RENDERING DEBUG: Auth loading:', authLoading);
                        console.log('🎯 VIEW RENDERING DEBUG: User:', !!user);
                        console.log('🎯 VIEW RENDERING DEBUG: Is admin:', isAdmin);
                        
                        if (currentView === 'landing') {
                            console.log('🎯 VIEW RENDERING DEBUG: Rendering LandingPage');
                            return (
                                <LandingPage 
                                    weeklyGoals={currentDayData?.goals?.weekly || []}
                                    monthlyGoals={currentDayData?.goals?.monthly || []}
                                    toggleGoal={toggleGoal}
                                    addGoal={addGoal}
                                    removeGoal={removeGoal}
                                    updateGoal={updateGoal}
                                    getWeeklyProgress={getWeeklyProgress}
                                    getMonthlyProgress={getMonthlyProgress}
                                    getDaysCompletedThisWeek={getDaysCompletedThisWeek}
                                    getCompletionRate={getCompletionRate}
                                    getCurrentStreak={getCurrentStreak}
                                    getWeeklySummary={getWeeklySummary}
                                    getHabitStrength={getHabitStrength}
                                    setCurrentView={setCurrentViewWithPersistence}
                                    forceRefreshFromNeon={forceRefreshFromNeon}
                                />
                            );
                        } else if (currentView === 'daily') {
                            console.log('🎯 VIEW RENDERING DEBUG: Rendering Daily View Components');
                            console.log('🎯 VIEW RENDERING DEBUG: currentDayData:', currentDayData);
                            return (
                                <>
                                    {/* Back to Dashboard Button */}
                                    <div className="mb-8">
                                        <button
                                            onClick={() => setCurrentViewWithPersistence('landing')}
                                            className="flex items-center gap-3 px-6 py-3 bg-gradient-to-r from-gray-100 to-gray-200 hover:from-gray-200 hover:to-gray-300 text-gray-800 rounded-xl transition-all duration-300 font-semibold border-2 border-gray-300 hover:border-gray-400 shadow-md hover:shadow-lg transform hover:-translate-y-1"
                                        >
                                            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
                                            </svg>
                                            Back to Dashboard
                                        </button>
                                    </div>

                                    {/* Check In Section */}
                                    <CheckInSection 
                                        checkIn={currentDayData?.checkIn || { emotions: [], feeling: '' }}
                                        onUpdate={updateCheckIn}
                                    />

                                    {/* Daily Intention Section */}
                                    <DailyIntentionSection 
                                        intention={currentDayData?.dailyIntention || ''}
                                        onUpdate={updateDailyIntention}
                                    />

                                    {/* Leadership Rating Section */}
                                    <LeadershipRatingSection 
                                        ratings={currentDayData?.leadershipRating || { wisdom: 5, courage: 5, patience: 5, integrity: 5 }}
                                        onUpdate={updateLeadershipRating}
                                    />

                                    {/* Growth Question Section */}
                                    <GrowthQuestionSection 
                                        question={currentDayData?.growthQuestion || ''}
                                        onUpdate={updateGrowthQuestion}
                                    />

                                    {/* Gratitude Section */}
                                    <GratitudeSection 
                                        gratitude={currentDayData?.gratitude || ['', '', '']}
                                        onUpdate={updateGratitude}
                                    />

                                    {/* SOAP Section */}
                                    <SOAPSection 
                                        soap={currentDayData?.soap || { scripture: '', observation: '', application: '', prayer: '' }}
                                        onUpdate={updateSOAP}
                                    />

                                    {/* Goals Section */}
                                    <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
                                <GoalSection 
                                    title="🎯 Daily Goals"
                                    subtitle="Today's objectives"
                                    goalType="daily"
                                    goals={currentDayData?.goals?.daily || []}
                                    onAdd={addGoal}
                                    onUpdate={updateGoal}
                                    onToggle={toggleGoal}
                                    onRemove={removeGoal}
                                    color="blue"
                                />
                                
                                <GoalSection 
                                    title="📅 Weekly Goals"
                                    subtitle="This week's focus"
                                    goalType="weekly"
                                    goals={currentDayData?.goals?.weekly || []}
                                    onAdd={addGoal}
                                    onUpdate={updateGoal}
                                    onToggle={toggleGoal}
                                    onRemove={removeGoal}
                                    color="green"
                                />
                                
                                <GoalSection 
                                    title="🗓️ Monthly Goals"
                                    subtitle="This month's vision"
                                    goalType="monthly"
                                    goals={currentDayData?.goals?.monthly || []}
                                    onAdd={addGoal}
                                    onUpdate={updateGoal}
                                    onToggle={toggleGoal}
                                    onRemove={removeGoal}
                                    color="purple"
                                />
                            </div>
                                </>
                            );
                        } else {
                            console.log('🎯 VIEW RENDERING DEBUG: No view matched, rendering null');
                            return null;
                        }
                    })()}

                    {/* Footer */}
                    <div className="mt-12 text-center">
                        <div className="section-divider"></div>
                        <p className="text-gray-500 text-sm flex items-center justify-center gap-2">
                            Built with <HeartIcon className="w-4 h-4 text-red-500" /> for spiritual growth and biblical discipleship
                        </p>
                        <p className="text-gray-400 text-xs mt-2">
                            "Be strong and courageous! Do not be afraid or discouraged. For the Lord your God is with you wherever you go." - Joshua 1:9
                        </p>
                    </div>
                </div>
            );
        };

        // Daily Intention Component
        const DailyIntentionSection = ({ intention, onUpdate }) => {
            const [localIntention, setLocalIntention] = useState(intention || '');

            useEffect(() => {
                setLocalIntention(intention || '');
            }, [intention]);

            const handleIntentionChange = (value) => {
                setLocalIntention(value);
                onUpdate(value);
            };

            return (
                <div className="modern-card mb-6">
                    <div className="bg-gradient-to-r from-slate-400 to-green-600 text-white p-6">
                        <h3 className="font-bold text-xl">🎯 DAILY INTENTION</h3>
                        <p className="text-white/90 text-sm mt-2">What's your main focus today?</p>
                    </div>
                    
                    <div className="p-6">
                        <textarea
                            value={localIntention}
                            onChange={(e) => handleIntentionChange(e.target.value)}
                            placeholder="Set your intention for today... (e.g., 'I will lead with patience and listen more than I speak')"
                            className="w-full text-sm border border-gray-300 rounded-lg px-4 py-3 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:border-blue-400 resize-none"
                            rows="3"
                        />
                    </div>
                </div>
            );
        };

        // Leadership Rating Component
        const LeadershipRatingSection = ({ ratings, onUpdate }) => {
            const [localRatings, setLocalRatings] = useState(ratings || {});

            useEffect(() => {
                setLocalRatings(ratings || {});
            }, [ratings]);

            const handleRatingChange = (trait, rating) => {
                const newRatings = { ...localRatings, [trait]: rating };
                setLocalRatings(newRatings);
                onUpdate(trait, rating);
            };

            const traits = [
                { key: 'wisdom', label: 'Wisdom', description: 'Making wise decisions' },
                { key: 'courage', label: 'Courage', description: 'Facing challenges boldly' },
                { key: 'patience', label: 'Patience', description: 'Waiting and enduring' },
                { key: 'integrity', label: 'Integrity', description: 'Living with honesty' }
            ];

            return (
                <div className="modern-card mb-6">
                    <div className="bg-gradient-to-r from-slate-400 to-green-600 text-white p-6">
                        <h3 className="font-bold text-xl">👑 LEADERSHIP RATING</h3>
                        <p className="text-white/90 text-sm mt-2">Rate yourself on key leadership traits (1-10)</p>
                    </div>
                    
                    <div className="p-6">
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                            {traits.map((trait) => (
                                <div key={trait.key} className="space-y-3">
                                    <div>
                                        <h4 className="font-medium text-gray-900">{trait.label}</h4>
                                        <p className="text-sm text-gray-600">{trait.description}</p>
                                    </div>
                                    <div className="flex items-center space-x-2">
                                        <span className="text-sm text-gray-600">1</span>
                                        <input
                                            type="range"
                                            min="1"
                                            max="10"
                                            value={localRatings[trait.key] || 5}
                                            onChange={(e) => handleRatingChange(trait.key, parseInt(e.target.value))}
                                            className="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider"
                                        />
                                        <span className="text-sm text-gray-600">10</span>
                                        <span className="text-lg font-bold text-green-600 w-8 text-center">
                                            {localRatings[trait.key] || 5}
                                        </span>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        // Growth Question Component
        const GrowthQuestionSection = ({ question, onUpdate }) => {
            const [localQuestion, setLocalQuestion] = useState(question || '');

            useEffect(() => {
                setLocalQuestion(question || '');
            }, [question]);

            const handleQuestionChange = (value) => {
                setLocalQuestion(value);
                onUpdate(value);
            };

            const dailyQuestions = [
                "What leadership opportunity did I take today?",
                "How did I serve my team/family today?",
                "What did I learn about myself today?",
                "When did I show courage today?",
                "How did I grow in patience today?",
                "What decision did I make that required wisdom?",
                "How did I demonstrate integrity today?"
            ];

            const todayQuestion = dailyQuestions[new Date().getDate() % dailyQuestions.length];

            return (
                <div className="modern-card mb-6">
                    <div className="bg-gradient-to-r from-slate-400 to-green-600 text-white p-6">
                        <h3 className="font-bold text-xl">🌱 GROWTH QUESTION</h3>
                        <p className="text-white/90 text-sm mt-2">Today's reflection: {todayQuestion}</p>
                    </div>
                    
                    <div className="p-6">
                        <textarea
                            value={localQuestion}
                            onChange={(e) => handleQuestionChange(e.target.value)}
                            placeholder="Reflect on today's growth question..."
                            className="w-full text-sm border border-gray-300 rounded-lg px-4 py-3 focus:outline-none focus:ring-2 focus:ring-purple-400 focus:border-purple-400 resize-none"
                            rows="3"
                        />
                    </div>
                </div>
            );
        };

        // Check In Component
        const CheckInSection = ({ checkIn, onUpdate }) => {
            const [localFeeling, setLocalFeeling] = useState(checkIn.feeling || '');
            const [localEmotions, setLocalEmotions] = useState(checkIn.emotions || []);

            useEffect(() => {
                setLocalFeeling(checkIn.feeling || '');
                setLocalEmotions(checkIn.emotions || []);
            }, [checkIn]);

            const handleEmotionToggle = (emotion) => {
                const newEmotions = localEmotions.includes(emotion)
                    ? localEmotions.filter(e => e !== emotion)
                    : [...localEmotions, emotion];
                
                setLocalEmotions(newEmotions);
                onUpdate({ emotions: newEmotions, feeling: localFeeling });
            };

            const handleFeelingChange = (value) => {
                setLocalFeeling(value);
                onUpdate({ emotions: localEmotions, feeling: value });
            };

            const emotionOptions = [
                { key: 'sad', label: 'Sad' },
                { key: 'angry', label: 'Angry' },
                { key: 'scared', label: 'Scared' },
                { key: 'happy', label: 'Happy' },
                { key: 'excited', label: 'Excited' },
                { key: 'tender', label: 'Tender' }
            ];

            return (
                <div className="modern-card mb-6" data-section="check-in">
                    <div className="bg-gradient-to-r from-slate-400 to-green-600 text-white p-6">
                        <h3 className="font-bold text-xl">💭 CHECK IN</h3>
                        <p className="text-white/90 text-sm mt-2">How are you feeling today?</p>
                    </div>
                    
                    <div className="p-6">
                        {/* Emotion Checkboxes */}
                        <div className="mb-6">
                            <h4 className="text-sm font-medium text-gray-700 mb-3">Select your emotions:</h4>
                            <div className="grid grid-cols-3 gap-3">
                                {emotionOptions.map((emotion) => (
                                    <label key={emotion.key} className="flex items-center space-x-2 cursor-pointer">
                                        <input
                                            type="checkbox"
                                            checked={localEmotions.includes(emotion.key)}
                                            onChange={() => handleEmotionToggle(emotion.key)}
                                            className="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
                                        />
                                        <span className={`px-3 py-2 rounded-lg border text-sm font-medium transition-colors ${
                                            localEmotions.includes(emotion.key) 
                                                ? 'bg-green-100 text-green-800 border-green-200' 
                                                : 'bg-gray-50 text-gray-600 border-gray-200 hover:bg-gray-100'
                                        }`}>
                                            {emotion.label}
                                        </span>
                                    </label>
                                ))}
                            </div>
                        </div>

                        {/* Feeling Text Area */}
                        <div>
                            <label className="block text-sm font-medium text-gray-700 mb-2">
                                How are you feeling? (optional)
                            </label>
                            <textarea
                                value={localFeeling}
                                onChange={(e) => handleFeelingChange(e.target.value)}
                                placeholder="Describe how you're feeling today..."
                                className="w-full text-sm border border-gray-300 rounded-lg px-4 py-3 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:border-blue-400 resize-none"
                                rows="3"
                            />
                        </div>
                    </div>
                </div>
            );
        };

        // Gratitude Component
        const GratitudeSection = ({ gratitude, onUpdate }) => {
            console.log('🎨 DEBUG: GratitudeSection rendering with:');
            console.log('🎨 DEBUG: gratitude:', gratitude);
            console.log('🎨 DEBUG: onUpdate:', onUpdate);
            console.log('🎨 DEBUG: gratitude.length:', gratitude?.length);
            
            const [localInputs, setLocalInputs] = useState({});

            useEffect(() => {
                console.log('🎨 DEBUG: GratitudeSection useEffect running');
                const newLocalInputs = {};
                gratitude.forEach((item, index) => {
                    newLocalInputs[index] = item;
                });
                setLocalInputs(newLocalInputs);
                console.log('🎨 DEBUG: localInputs set to:', newLocalInputs);
            }, [gratitude]);

            const handleInputChange = (index, value) => {
                setLocalInputs(prev => ({ ...prev, [index]: value }));
            };

            const handleInputBlur = (index) => {
                console.log('📝 DEBUG: handleInputBlur called with:');
                console.log('📝 DEBUG: index:', index);
                console.log('📝 DEBUG: localValue:', localInputs[index]);
                console.log('📝 DEBUG: currentItem:', gratitude[index]);
                console.log('📝 DEBUG: localValue !== currentItem:', localInputs[index] !== gratitude[index]);
                
                const localValue = localInputs[index];
                const currentItem = gratitude[index];
                if (localValue !== undefined && currentItem !== localValue) {
                    console.log('📝 DEBUG: Calling onUpdate with:', index, localValue);
                    onUpdate(index, localValue);
                } else {
                    console.log('📝 DEBUG: NOT calling onUpdate - values are the same or undefined');
                }
            };

            return (
                <div className="section-card rounded-xl p-6 mb-8">
                    <div className="text-center mb-6">
                        <h2 className="section-header text-2xl font-bold mb-2 flex items-center justify-center gap-2">
                            🙏 Daily Gratitude
                        </h2>
                        <p className="text-gray-600">
                            "Give thanks in all circumstances" - 1 Thessalonians 5:18
                        </p>
                    </div>

                    <div className="section-divider"></div>

                    <div className="space-y-4 max-w-4xl mx-auto">
                        {gratitude.map((item, index) => (
                            <div key={index} className="relative">
                                <textarea
                                    value={localInputs[index] !== undefined ? localInputs[index] : item}
                                    onChange={(e) => handleInputChange(index, e.target.value)}
                                    onBlur={() => handleInputBlur(index)}
                                    className="w-full text-base border-2 border-green-200 focus:border-green-400 focus:ring-2 focus:ring-green-200 rounded-xl px-5 py-4 resize-none min-h-[3rem] focus:outline-none transition-all duration-200 placeholder-gray-400"
                                    placeholder={`I'm grateful for...`}
                                    rows="1"
                                    onInput={(e) => {
                                        e.target.style.height = 'auto';
                                        e.target.style.height = e.target.scrollHeight + 'px';
                                    }}
                                />
                                <div className="absolute left-2 top-4 text-green-600 font-bold text-sm">
                                    {index + 1}.
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        // SOAP Component
        const SOAPSection = ({ soap, onUpdate }) => {
            const [localInputs, setLocalInputs] = useState({});

            useEffect(() => {
                setLocalInputs({
                    scripture: soap.scripture,
                    observation: soap.observation,
                    application: soap.application,
                    prayer: soap.prayer
                });
            }, [soap]);

            const handleInputChange = (section, value) => {
                setLocalInputs(prev => ({ ...prev, [section]: value }));
            };

            const handleInputBlur = (section) => {
                const localValue = localInputs[section];
                const currentValue = soap[section];
                if (localValue !== undefined && currentValue !== localValue) {
                    onUpdate(section, localValue);
                }
            };

            const sectionConfigs = {
                scripture: {
                    title: "📖 Scripture",
                    subtitle: "Today's Bible passage",
                    placeholder: "Enter the Bible verse or passage you're studying today...",
                    color: "green"
                },
                observation: {
                    title: "👁️ Observation",
                    subtitle: "What does the passage say?",
                    placeholder: "What do you notice about this passage? What stands out? What context is important?",
                    color: "emerald"
                },
                application: {
                    title: "🎯 Application",
                    subtitle: "How does this apply to your life?",
                    placeholder: "How can you apply this passage to your life today? What changes will you make?",
                    color: "teal"
                },
                prayer: {
                    title: "🙏 Prayer",
                    subtitle: "Your response to God",
                    placeholder: "How will you pray based on this passage? What are you asking God for?",
                    color: "green"
                }
            };

            return (
                <div className="soap-card p-8 mb-8">
                    <div className="text-center mb-8">
                        <h2 className="section-header text-3xl font-bold mb-2">
                            S.O.A.P. Study
                        </h2>
                        <p className="text-gray-600 text-lg">
                            Scripture • Observation • Application • Prayer
                        </p>
                        <div className="mt-4 text-sm text-gray-500">
                            "All Scripture is God-breathed and is useful for teaching, rebuking, correcting and training in righteousness" - 2 Timothy 3:16
                        </div>
                    </div>

                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                        {Object.entries(sectionConfigs).map(([section, config]) => (
                            <div key={section} className="modern-card border-l-4 border-l-green-500">
                                <div className="p-6">
                                    <h3 className="font-bold text-xl mb-2 text-gray-800">
                                        {config.title}
                                    </h3>
                                    <p className="text-gray-600 text-sm mb-4">
                                        {config.subtitle}
                                    </p>
                                    
                                    <textarea
                                        value={localInputs[section] || ''}
                                        onChange={(e) => handleInputChange(section, e.target.value)}
                                        onBlur={() => handleInputBlur(section)}
                                        className={`w-full text-base border-2 border-gray-200 focus:border-${config.color}-400 focus:ring-2 focus:ring-${config.color}-200 rounded-xl px-4 py-4 resize-none min-h-[150px] focus:outline-none transition-all duration-200 placeholder-gray-400`}
                                        placeholder={config.placeholder}
                                        rows="6"
                                    />
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        // Goal Section Component
        const GoalSection = ({ title, subtitle, goalType, goals, onAdd, onUpdate, onToggle, onRemove, color }) => {
            const [localInputs, setLocalInputs] = useState({});
            const [editingGoal, setEditingGoal] = useState(null);
            const [editForm, setEditForm] = useState({ text: '', category: 'spiritual' });
            const [showAddForm, setShowAddForm] = useState(false);
            const [newGoalText, setNewGoalText] = useState('');
            const [newGoalCategory, setNewGoalCategory] = useState('spiritual');


            useEffect(() => {
                const newLocalInputs = {};
                goals.forEach(goal => {
                    if (!(goal.id in localInputs)) {
                        newLocalInputs[goal.id] = goal.text;
                    }
                });
                if (Object.keys(newLocalInputs).length > 0) {
                    setLocalInputs(prev => ({ ...prev, ...newLocalInputs }));
                }
            }, [goals]);

            // Handle adding new goals
            const handleAddNewGoal = () => {
                if (newGoalText.trim()) {
                    onAdd(goalType, newGoalText.trim(), newGoalCategory);
                    setNewGoalText('');
                    setNewGoalCategory('spiritual');
                    setShowAddForm(false);
                }
            };

            const handleInputChange = (id, value) => {
                setLocalInputs(prev => ({ ...prev, [id]: value }));
            };

            const handleInputBlur = (id) => {
                const localValue = localInputs[id];
                const currentGoal = goals.find(goal => goal.id === id);
                if (localValue !== undefined && currentGoal && localValue !== currentGoal.text) {
                    onUpdate(goalType, id, localValue);
                }
            };



            const startEditing = (goal) => {
                setEditingGoal(goal.id);
                setEditForm({ text: goal.text, category: goal.category || 'spiritual' });
            };

            const saveEdit = () => {
                if (editForm.text.trim()) {
                    onUpdate(goalType, editingGoal, editForm.text, editForm.category);
                    setEditingGoal(null);
                    setEditForm({ text: '', category: 'spiritual' });
                } else {
                    // If no text entered, remove the empty goal
                    onRemove(goalType, editingGoal);
                    setEditingGoal(null);
                    setEditForm({ text: '', category: 'spiritual' });
                }
            };

            const cancelEdit = () => {
                setEditingGoal(null);
                setEditForm({ text: '', category: 'spiritual' });
            };

            const CheckIcon = () => (
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                </svg>
            );

            const TrashIcon = () => (
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                </svg>
            );

            const EditIcon = () => (
                <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                </svg>
            );

            const colorClasses = {
                blue: {
                    header: 'from-slate-400 to-green-600',
                    button: 'bg-green-50 hover:bg-green-100 text-green-700 border-green-200',
                    check: 'bg-green-600 border-green-600'
                },
                green: {
                    header: 'from-slate-500 to-green-700',
                    button: 'bg-green-50 hover:bg-green-100 text-green-700 border-green-200',
                    check: 'bg-green-700 border-green-700'
                },
                purple: {
                    header: 'from-slate-600 to-green-800',
                    button: 'bg-green-50 hover:bg-green-100 text-green-700 border-green-200',
                    check: 'bg-green-800 border-green-800'
                }
            };

            const colors = colorClasses[color] || colorClasses.blue; // Default to blue if color is undefined

            return (
                <div className="modern-card overflow-hidden">
                    <div className={`bg-gradient-to-r ${colors.header} text-white p-6`}>
                        <h3 className="font-bold text-xl">{title}</h3>
                        <p className="text-white/90 text-sm mt-2">{subtitle}</p>
                    </div>

                    <div className="p-6">
                        <div className="space-y-4 mb-6">
                            {goals.map((goal) => (
                                <div key={goal.id} className="space-y-3">
                                    {editingGoal === goal.id ? (
                                        // Edit Mode
                                        <div className="p-4 bg-blue-50 border border-blue-200 rounded-lg">
                                            <div className="space-y-3">
                                                <div>
                                                    <label className="block text-sm font-medium text-gray-700 mb-1">
                                                        Goal Text
                                                    </label>
                                                    <textarea
                                                        value={editForm.text}
                                                        onChange={(e) => setEditForm(prev => ({ ...prev, text: e.target.value }))}
                                                        className="w-full text-sm border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:border-blue-400 resize-none min-h-[2.5rem]"
                                                        placeholder="What do you want to accomplish today?"
                                                        rows="2"
                                                        autoFocus
                                                    />
                                                </div>
                                                <div>
                                                    <label className="block text-sm font-medium text-gray-700 mb-1">
                                                        Category
                                                    </label>
                                                    <select
                                                        value={editForm.category}
                                                        onChange={(e) => setEditForm(prev => ({ ...prev, category: e.target.value }))}
                                                        className="w-full text-sm border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:border-blue-400"
                                                    >
                                                        <option value="spiritual">Spiritual</option>
                                                        <option value="personal">Personal</option>
                                                        <option value="outreach">Outreach</option>
                                                        <option value="health">Health</option>
                                                        <option value="work">Work</option>
                                                    </select>
                                                </div>
                                                <div className="flex space-x-2">
                                                    <button
                                                        onClick={saveEdit}
                                                        className="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm transition-colors"
                                                    >
                                                        Save
                                                    </button>
                                                    <button
                                                        onClick={cancelEdit}
                                                        className="bg-gray-500 hover:bg-gray-600 text-white px-3 py-1 rounded text-sm transition-colors"
                                                    >
                                                        Cancel
                                                    </button>
                                                    <button
                                                        onClick={() => {
                                                            onRemove(goalType, goal.id);
                                                            setEditingGoal(null);
                                                        }}
                                                        className="bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded text-sm transition-colors"
                                                    >
                                                        Delete
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                    ) : (
                                        // View Mode
                                        <div className="flex items-start gap-3 group">
                                            <button
                                                onClick={() => onToggle(goalType, goal.id)}
                                                className={`mt-1 w-6 h-6 rounded-full border-2 flex items-center justify-center transition-all duration-200 hover:scale-110 ${
                                                    goal.completed 
                                                        ? `${colors.check} text-white shadow-lg` 
                                                        : `border-gray-300 hover:border-${color}-400 hover:bg-gray-50`
                                                }`}
                                            >
                                                {goal.completed && <CheckIcon />}
                                            </button>
                                            
                                            <div className="flex-1 min-w-0">
                                                <div className="text-sm text-gray-800 mb-1">
                                                    {goal.text}
                                                </div>
                                                {goal.category && (
                                                    <span className={`inline-block px-2 py-1 text-xs rounded-full font-medium ${
                                                        goal.category === 'spiritual' ? 'bg-blue-100 text-blue-800' :
                                                        goal.category === 'personal' ? 'bg-green-100 text-green-800' :
                                                        goal.category === 'outreach' ? 'bg-purple-100 text-purple-800' :
                                                        goal.category === 'health' ? 'bg-amber-100 text-amber-800' :
                                                        'bg-gray-100 text-gray-800'
                                                    }`}>
                                                        {goal.category === 'spiritual' ? 'Spiritual' :
                                                         goal.category === 'personal' ? 'Personal' :
                                                         goal.category === 'outreach' ? 'Outreach' :
                                                         goal.category === 'health' ? 'Health' :
                                                         goal.category === 'work' ? 'Work' :
                                                         goal.category}
                                                    </span>
                                                )}
                                            </div>
                                            
                                            <div className="flex space-x-1 opacity-0 group-hover:opacity-100 transition-opacity">
                                                <button
                                                    onClick={() => startEditing(goal)}
                                                    className="text-blue-600 hover:text-blue-700 p-2 rounded-full hover:bg-blue-50 transition-colors"
                                                    title="Edit goal"
                                                >
                                                    <EditIcon />
                                                </button>
                                                <button
                                                    onClick={() => onRemove(goalType, goal.id)}
                                                    className="text-red-500 hover:text-red-700 p-2 rounded-full hover:bg-red-50 transition-colors"
                                                    title="Remove goal"
                                                >
                                                    <TrashIcon />
                                                </button>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            ))}
                        </div>

                        <button
                            onClick={() => setShowAddForm(true)}
                            className={`w-full py-3 border-2 border-dashed rounded-xl transition-all duration-200 flex items-center justify-center gap-2 font-medium hover:scale-[1.02] ${colors.button}`}
                        >
                            <PlusIcon />
                            Add Goal
                        </button>

                        {/* Add Goal Form */}
                        {showAddForm && (
                            <div className="mt-4 p-4 bg-gray-50 rounded-lg">
                                <div className="space-y-3">
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-1">
                                            Goal Text
                                        </label>
                                        <textarea
                                            value={newGoalText}
                                            onChange={(e) => setNewGoalText(e.target.value)}
                                            placeholder={`What do you want to accomplish ${goalType === 'daily' ? 'today' : goalType === 'weekly' ? 'this week' : 'this month'}?`}
                                            className="w-full text-sm border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:border-blue-400 resize-none"
                                            rows="2"
                                            autoFocus
                                        />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-1">
                                            Category
                                        </label>
                                        <select
                                            value={newGoalCategory}
                                            onChange={(e) => setNewGoalCategory(e.target.value)}
                                            className="w-full text-sm border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:border-blue-400"
                                        >
                                            <option value="spiritual">Spiritual</option>
                                            <option value="personal">Personal</option>
                                            <option value="outreach">Outreach</option>
                                            <option value="health">Health</option>
                                            <option value="work">Work</option>
                                        </select>
                                    </div>
                                    <div className="flex space-x-2">
                                        <button
                                            onClick={handleAddNewGoal}
                                            className="bg-primary hover:bg-green-700 text-white px-4 py-2 rounded-md transition-colors"
                                        >
                                            Add Goal
                                        </button>
                                        <button
                                            onClick={() => {
                                                setShowAddForm(false);
                                                setNewGoalText('');
                                                setNewGoalCategory('spiritual');
                                            }}
                                            className="px-4 py-2 text-gray-600 border border-gray-300 rounded-md hover:bg-gray-50 transition-colors"
                                        >
                                            Cancel
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}

                        {goals.length > 0 && (
                            <div className="mt-4 pt-4 border-t border-gray-200">
                                <div className="flex justify-between text-sm text-gray-600 font-medium">
                                    <span>{goals.length} total</span>
                                    <span>{goals.filter(goal => goal.completed).length} completed</span>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        ReactDOM.render(<DailyDavidApp />, document.getElementById('root'));
    </script>
</body>
</html>
